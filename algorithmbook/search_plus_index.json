{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitboook-publishable-template template to use for publishing gitbooks to github.com You can duplicate this repositoryhttps://help.github.com/articles/duplicating-a-repository/ Create a new repository on github.com Create a bare clone of this repositorygit clone --bare https://github.com/rebeccapeltz/gitbook-publishable-template.git Mirror-push to new repositorycd gitbook-publishable-template.gitgit push --mirror https://github.com/useraccount/new-repository.git Remove the temporary repository create abovecd ..rm -rf old-repository.git Alternatively, you can also just download a zipped file of this repository and then use standard commands to push to initialize and push to your new repository. git init git add . git commit -m\"first commit\" git remote add origin git@github.com:useraccount/new-repository.git git push origin master "},"leetcode/two-sum.html":{"url":"leetcode/two-sum.html","title":"1.Two Sum","keywords":"","body":"1. Two Sum Difficulty: Easy Topics: Array, Hash Table Similar Questions: 3Sum 4Sum Two Sum II - Input array is sorted Two Sum III - Data structure design Subarray Sum Equals K Two Sum IV - Input is a BST Two Sum Less Than K Problem: Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solutions: class Solution { public: vector twoSum(vector& nums, int target) { unordered_map numToIndex; for (int i = 0; i 0) { return {numToIndex[target - nums[i]], i}; } numToIndex[nums[i]] = i; } return {}; } }; "},"leetcode/add-two-numbers.html":{"url":"leetcode/add-two-numbers.html","title":"2.Add Two Numbers","keywords":"","body":"2. Add Two Numbers Difficulty: Medium Topics: Linked List, Math Similar Questions: Multiply Strings Add Binary Sum of Two Integers Add Strings Add Two Numbers II Add to Array-Form of Integer Problem: You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* head = new ListNode(0); ListNode* cur = head; int carry = 0; while (l1 != NULL || l2 != NULL) { int val1 = 0; int val2 = 0; if (l1) { val1 = l1->val; l1 = l1->next; } if (l2) { val2 = l2->val; l2 = l2->next; } int sum = val1 + val2 + carry; carry = sum/10; cur->next = new ListNode(sum%10); cur = cur->next; } if (carry == 1) { cur->next = new ListNode(1); } return head->next; } }; "},"leetcode/longest-substring-without-repeating-characters.html":{"url":"leetcode/longest-substring-without-repeating-characters.html","title":"3.Longest Substring Without Repeating Characters","keywords":"","body":"3. Longest Substring Without Repeating Characters Difficulty: Medium Topics: Hash Table, Two Pointers, String, Sliding Window Similar Questions: Longest Substring with At Most Two Distinct Characters Longest Substring with At Most K Distinct Characters Subarrays with K Different Integers Problem: Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Solutions: class Solution { public: int lengthOfLongestSubstring(string s) { int charPos[256] {0}; // initialization only for 0, not for other values for (int i = 0; i "},"leetcode/median-of-two-sorted-arrays.html":{"url":"leetcode/median-of-two-sorted-arrays.html","title":"4.Median of Two Sorted Arrays","keywords":"","body":"4. Median of Two Sorted Arrays Difficulty: Hard Topics: Array, Binary Search, Divide and Conquer Similar Questions: Problem: There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solutions: class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { int n1 = nums1.size(); int n2 = nums2.size(); int n = n1 + n2; if (n % 2 == 0) { return (smallK(n/2, nums1, 0, n1 - 1, nums2, 0, n2 - 1) + smallK(n/2 + 1, nums1, 0, n1 - 1, nums2, 0, n2 - 1)) / double(2); } else { return smallK(n/2 + 1, nums1, 0, n1 - 1, nums2, 0, n2 - 1); } } // k starting from 1 int smallK(int k, vector& nums1, int left1, int right1, vector& nums2, int left2, int right2) { if (left1 > right1) return nums2[left2 + k - 1]; if (left2 > right2) return nums1[left1 + k - 1]; if (k == 1) { return min(nums1[left1], nums2[left2]); } if (k/2 > right1 - left1 + 1) { return smallK(k - k/2, nums1, left1, right1, nums2, left2 + k/2, right2); } if (k/2 > right2 - left2 + 1) { return smallK(k - k/2, nums1, left1 + k/2, right1, nums2, left2, right2); } if (nums1[left1 + k/2 - 1] "},"leetcode/longest-palindromic-substring.html":{"url":"leetcode/longest-palindromic-substring.html","title":"5.Longest Palindromic Substring","keywords":"","body":"5. Longest Palindromic Substring Difficulty: Medium Topics: String, Dynamic Programming Similar Questions: Shortest Palindrome Palindrome Permutation Palindrome Pairs Longest Palindromic Subsequence Palindromic Substrings Problem: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" Solutions: class Solution { public: string longestPalindrome(string s) { int n = s.length(); int length1 = 0; int length2 = 0; int ret = 0; int len = 0; for (int center = 0; center = 0 && right1 len) { len = length1; ret = left1 + 1; } int count2 = 0; int left2 = center; int right2 = center + 1; while (left2 >= 0 && right2 len) { len = length2; ret = left2 + 1; } } return s.substr(ret, len); } }; "},"leetcode/zigzag-conversion.html":{"url":"leetcode/zigzag-conversion.html","title":"6.ZigZag Conversion","keywords":"","body":"6. ZigZag Conversion Difficulty: Medium Topics: String Similar Questions: Problem: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Solutions: class Solution { public: string convert(string s, int numRows) { if (numRows == 0) return \"\"; if (numRows == 1) return s; int period = 2 * (numRows - 1); string ret; for (int row = 0; row "},"leetcode/reverse-integer.html":{"url":"leetcode/reverse-integer.html","title":"7.Reverse Integer","keywords":"","body":"7. Reverse Integer Difficulty: Easy Topics: Math Similar Questions: String to Integer (atoi) Reverse Bits Problem: Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Solutions: class Solution { public: int reverse(int x) { bool sign = (x >= 0); if (x == INT_MIN) return 0; x = abs(x); // it is wrong if x is INT_MIN because of overflow. int ret = 0; while (x > 0) { int digit = x%10; x /= 10; if (ret > INT_MAX/10 || (ret == INT_MAX/10 && (sign ? digit > INT_MAX%10 : digit > INT_MAX%10 + 1))) return 0; // the priority of conditional operator is low && abs(INT_MIN) is forbidon!!! ret = ret * 10 + digit; } return sign ? ret : -ret; } }; "},"leetcode/string-to-integer-atoi.html":{"url":"leetcode/string-to-integer-atoi.html","title":"8.String to Integer (atoi)","keywords":"","body":"8. String to Integer (atoi) Difficulty: Medium Topics: Math, String Similar Questions: Reverse Integer Valid Number Problem: Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.   Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical   digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer.   Thefore INT_MIN (−231) is returned. Solutions: class Solution { public: int myAtoi(string str) { int cur = 0; while (cur INT_MAX/10 || ret == INT_MAX/10 && digit > INT_MAX%10 ) { // only compare INT_MAX otherwise the case of \"-2147483648\" is wrong. return sign == 1 ? INT_MAX : INT_MIN; } ret = ret * 10 + digit; ++cur; // remember to increase cur } return sign == 1 ? ret : -ret; } }; "},"leetcode/palindrome-number.html":{"url":"leetcode/palindrome-number.html","title":"9.Palindrome Number","keywords":"","body":"9. Palindrome Number Difficulty: Easy Topics: Math Similar Questions: Palindrome Linked List Problem: Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? Solutions: class Solution { public: bool isPalindrome(int x) { if (x 0) { int digit = val % 10; val = val/10; if (reverse > INT_MAX/10 || reverse == INT_MAX/10 && digit > INT_MAX % 10) return false; // remember to check overflow! reverse = 10 * reverse + digit; } return reverse == x; } }; "},"leetcode/regular-expression-matching.html":{"url":"leetcode/regular-expression-matching.html","title":"10.Regular Expression Matching","keywords":"","body":"10. Regular Expression Matching Difficulty: Hard Topics: String, Dynamic Programming, Backtracking Similar Questions: Wildcard Matching Problem: Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\" p = \".*\" Output: true Explanation: \".*\" means \"zero or more (*) of any character (.)\". Example 4: Input: s = \"aab\" p = \"c*a*b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\" p = \"mis*is*p*.\" Output: false Solutions: class Solution { public: bool isMatch(string s, string p) { int m = s.length(); int n = p.length(); vector> dp(m + 1, vector(n + 1, false)); dp[0][0] = true; // when s is empty for (int j = 1; j "},"leetcode/container-with-most-water.html":{"url":"leetcode/container-with-most-water.html","title":"11.Container With Most Water","keywords":"","body":"11. Container With Most Water Difficulty: Medium Topics: Array, Two Pointers Similar Questions: Trapping Rain Water Problem: Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.   The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.   Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Solutions: class Solution { public: int maxArea(vector& height) { int left = 0; int right = height.size() - 1; int ret = 0; while (left "},"leetcode/integer-to-roman.html":{"url":"leetcode/integer-to-roman.html","title":"12.Integer to Roman","keywords":"","body":"12. Integer to Roman Difficulty: Medium Topics: Math, String Similar Questions: Roman to Integer Integer to English Words Problem: Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Solutions: class Solution { public: string intToRoman(int num) { vector> values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, {'?', 5000}, {'*', 10000} }; string ret; vector digits; for (int i = 0; i = 0; --i) { populateStr(ret, digits[i], values[i*2 + 2].first, values[i*2 + 1].first, values[i*2].first); } return ret; } void populateStr(string& ret, int digit, char tenChar, char fiveChar, char oneChar) { if (digit == 0) return; if (digit "},"leetcode/roman-to-integer.html":{"url":"leetcode/roman-to-integer.html","title":"13.Roman to Integer","keywords":"","body":"13. Roman to Integer Difficulty: Easy Topics: Math, String Similar Questions: Integer to Roman Problem: Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Solutions: class Solution { public: int romanToInt(string s) { unordered_map romanVal {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}}; int last = 0; int ret = 0; for (int i = s.length() - 1; i >= 0; --i) { int val = romanVal[s[i]]; if (val >= last) { ret += val; } else { ret -= val; } last = val; } return ret; } }; "},"leetcode/longest-common-prefix.html":{"url":"leetcode/longest-common-prefix.html","title":"14.Longest Common Prefix","keywords":"","body":"14. Longest Common Prefix Difficulty: Easy Topics: String Similar Questions: Problem: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solutions: class Solution { public: string longestCommonPrefix(vector& strs) { string ret; if (strs.empty()) return ret; int i = 0; while (true) { if (i >= strs[0].length()) return ret; char commonChar = strs[0][i]; for (auto& str : strs) { if (i >= str.length() || commonChar != str[i]) return ret; } ret.push_back(commonChar); ++i; } } }; "},"leetcode/3sum.html":{"url":"leetcode/3sum.html","title":"15.3Sum","keywords":"","body":"15. 3Sum Difficulty: Medium Topics: Array, Two Pointers Similar Questions: Two Sum 3Sum Closest 4Sum 3Sum Smaller Problem: Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Solutions: class Solution { public: vector> threeSum(vector& nums) { vector> result; sort(nums.begin(), nums.end()); for (int i = 0; i 0 && nums[i] == nums[i-1]) continue; // deduplication int sum = -nums[i]; int left = i + 1; int right = nums.size() - 1; while (left sum) { right--; } else { left++; } } } return result; } }; "},"leetcode/3sum-closest.html":{"url":"leetcode/3sum-closest.html","title":"16.3Sum Closest","keywords":"","body":"16. 3Sum Closest Difficulty: Medium Topics: Array, Two Pointers Similar Questions: 3Sum 3Sum Smaller Problem: Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Solutions: class Solution { public: int threeSumClosest(vector& nums, int target) { if (nums.size() "},"leetcode/letter-combinations-of-a-phone-number.html":{"url":"leetcode/letter-combinations-of-a-phone-number.html","title":"17.Letter Combinations of a Phone Number","keywords":"","body":"17. Letter Combinations of a Phone Number Difficulty: Medium Topics: String, Backtracking Similar Questions: Generate Parentheses Combination Sum Binary Watch Problem: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Solutions: class Solution { public: vector letterCombinations(string digits) { vector ret; if (digits.length() == 0) return ret; int pos = 0; string path; dfs(digits, pos, path, ret); return ret; } void dfs(string digits, int pos, string& path, vector& ret) { if (pos == digits.length()) { ret.push_back(path); return; } char digit = digits[pos]; for (auto c : numToLetters[digit]) { path.push_back(c); dfs(digits, pos + 1, path, ret); path.pop_back(); } } private: unordered_map numToLetters { {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; }; "},"leetcode/4sum.html":{"url":"leetcode/4sum.html","title":"18.4Sum","keywords":"","body":"18. 4Sum Difficulty: Medium Topics: Array, Hash Table, Two Pointers Similar Questions: Two Sum 3Sum 4Sum II Problem: Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] Solutions: class Solution { public: vector> fourSum(vector& nums, int target) { if (nums.size() > ret; for (int a = 0; a 0 && nums[a] == nums[a - 1]) continue; for (int b = a + 1; b a + 1 && nums[b] == nums[b-1]) continue; int c = b + 1; int d = nums.size() - 1; while (c "},"leetcode/remove-nth-node-from-end-of-list.html":{"url":"leetcode/remove-nth-node-from-end-of-list.html","title":"19.Remove Nth Node From End of List","keywords":"","body":"19. Remove Nth Node From End of List Difficulty: Medium Topics: Linked List, Two Pointers Similar Questions: Problem: Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Follow up: Could you do this in one pass? Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* front = head; for (int i = 0; i next; } if (front == NULL) { return head->next; } front = front->next; ListNode* cur = head; while (front != NULL) { front = front->next; cur = cur->next; } cur->next = cur->next->next; return head; } }; "},"leetcode/valid-parentheses.html":{"url":"leetcode/valid-parentheses.html","title":"20.Valid Parentheses","keywords":"","body":"20. Valid Parentheses Difficulty: Easy Topics: String, Stack Similar Questions: Generate Parentheses Longest Valid Parentheses Remove Invalid Parentheses Check If Word Is Valid After Substitutions Problem: Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true Solutions: class Solution { public: bool isValid(string s) { stack stk; for (auto c : s) { switch(c) { case '(': case '{': case '[': stk.push(c); break; case ')': if (stk.empty() || stk.top() != '(') return false; stk.pop(); break; case '}': if (stk.empty() || stk.top() != '{') return false; stk.pop(); break; case ']': if (stk.empty() || stk.top() != '[') return false; stk.pop(); break; default: continue; } } return stk.empty(); } }; "},"leetcode/merge-two-sorted-lists.html":{"url":"leetcode/merge-two-sorted-lists.html","title":"21.Merge Two Sorted Lists","keywords":"","body":"21. Merge Two Sorted Lists Difficulty: Easy Topics: Linked List Similar Questions: Merge k Sorted Lists Merge Sorted Array Sort List Shortest Word Distance II Problem: Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* head = NULL; ListNode** cur = &head; while (l1 != NULL || l2 != NULL) { if (l1 == NULL) { *cur = l2; l2 = l2 -> next; } else if (l2 == NULL) { *cur = l1; l1 = l1 ->next; } else { if (l1->val val) { *cur = l1; l1 = l1->next; } else { *cur = l2; l2 = l2->next; } } cur = &((*cur)->next); } return head; } }; "},"leetcode/generate-parentheses.html":{"url":"leetcode/generate-parentheses.html","title":"22.Generate Parentheses","keywords":"","body":"22. Generate Parentheses Difficulty: Medium Topics: String, Backtracking Similar Questions: Letter Combinations of a Phone Number Valid Parentheses Problem: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] Solutions: class Solution { public: vector generateParenthesis(int n) { vector ret; if (n == 0) return ret; string path; helper(2 * n, 0, path, ret); return ret; } void helper(int remain, int left, string& path, vector& ret) { if (remain == 0 && left == 0) { ret.push_back(path); return; } if (left "},"leetcode/merge-k-sorted-lists.html":{"url":"leetcode/merge-k-sorted-lists.html","title":"23.Merge k Sorted Lists","keywords":"","body":"23. Merge k Sorted Lists Difficulty: Hard Topics: Linked List, Divide and Conquer, Heap Similar Questions: Merge Two Sorted Lists Ugly Number II Problem: Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [   1->4->5,   1->3->4,   2->6 ] Output: 1->1->2->3->4->4->5->6 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: struct NodeInfo { ListNode* node; int srcList; NodeInfo(ListNode* node, int srcList) { this->node = node; this->srcList = srcList; } bool operatornode->val val; } bool operator>(const NodeInfo& another) const { return this->node->val > another.node->val; } }; ListNode* mergeKLists(vector& lists) { int n = lists.size(); priority_queue, greater> pq; ListNode* dummyHead = new ListNode(0); ListNode* tail = dummyHead; for (int i = 0; i next; } } while (!pq.empty()) { NodeInfo nodeInfo = pq.top(); pq.pop(); int srcList = nodeInfo.srcList; ListNode* node = nodeInfo.node; tail->next = node; tail = node; if (lists[srcList] != NULL) { pq.push({lists[srcList], srcList}); lists[srcList] = lists[srcList]->next; } } return dummyHead->next; } }; "},"leetcode/swap-nodes-in-pairs.html":{"url":"leetcode/swap-nodes-in-pairs.html","title":"24.Swap Nodes in Pairs","keywords":"","body":"24. Swap Nodes in Pairs Difficulty: Medium Topics: Linked List Similar Questions: Reverse Nodes in k-Group Problem: Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed.   Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); ListNode* tail = dummyHead; while (head && head->next) { ListNode* first = head; ListNode* second = head->next; head = head->next->next; // remember to the head of next round intermidiately tail->next = second; second->next = first; tail = first; tail->next = nullptr; } if (head) { tail->next = head; } return dummyHead->next; } }; "},"leetcode/reverse-nodes-in-k-group.html":{"url":"leetcode/reverse-nodes-in-k-group.html","title":"25.Reverse Nodes in k-Group","keywords":"","body":"25. Reverse Nodes in k-Group Difficulty: Hard Topics: Linked List Similar Questions: Swap Nodes in Pairs Problem: Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note: Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed. Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode* dummyHead = new ListNode(0); ListNode* tail = dummyHead; ListNode* left = head; int count = 0; while (head) { ++count; ListNode* nextNode = head->next; if (k == count) { tail->next = reverse(left, k); tail = left; left = nextNode; count = 0; } head = nextNode; } tail->next = left; return dummyHead->next; } ListNode* reverse(ListNode* head, int k) { ListNode* dummyHead = new ListNode(0); while (k-- > 0) { ListNode* nextNode = head->next; head->next = dummyHead->next; dummyHead->next = head; head = nextNode; } return dummyHead->next; } }; "},"leetcode/remove-duplicates-from-sorted-array.html":{"url":"leetcode/remove-duplicates-from-sorted-array.html","title":"26.Remove Duplicates from Sorted Array","keywords":"","body":"26. Remove Duplicates from Sorted Array Difficulty: Easy Topics: Array, Two Pointers Similar Questions: Remove Element Remove Duplicates from Sorted Array II Problem: Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i Solutions: class Solution { public: int removeDuplicates(vector& nums) { int len = 0; for (int i = 0; i 0 && nums[i] == nums[i-1]) continue; nums[len++] = nums[i]; } return len; } }; "},"leetcode/remove-element.html":{"url":"leetcode/remove-element.html","title":"27.Remove Element","keywords":"","body":"27. Remove Element Difficulty: Easy Topics: Array, Two Pointers Similar Questions: Remove Duplicates from Sorted Array Remove Linked List Elements Move Zeroes Problem: Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i Solutions: class Solution { public: int removeElement(vector& nums, int val) { int cur = 0; for (int i = 0; i "},"leetcode/implement-strstr.html":{"url":"leetcode/implement-strstr.html","title":"28.Implement strStr()","keywords":"","body":"28. Implement strStr() Difficulty: Easy Topics: Two Pointers, String Similar Questions: Shortest Palindrome Repeated Substring Pattern Problem: Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf(). Solutions: class Solution { public: int strStr(string haystack, string needle) { if (haystack.length() "},"leetcode/divide-two-integers.html":{"url":"leetcode/divide-two-integers.html","title":"29.Divide Two Integers","keywords":"","body":"29. Divide Two Integers Difficulty: Medium Topics: Math, Binary Search Similar Questions: Problem: Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. Solutions: class Solution { public: int divide(int dividend, int divisor) { if (dividend == INT_MIN && divisor == -1) return INT_MAX; if (dividend == INT_MIN && divisor == 1) return INT_MIN; if (dividend == INT_MIN && divisor == INT_MIN) return 1; if (divisor == INT_MIN) { return 0; } int sign = 1; if ((dividend >= 0 && divisor = 0)) { sign = -1; } divisor = abs(divisor); int carry = 0; if (dividend == INT_MIN) { dividend += divisor; carry = 1; } dividend = abs(dividend); int ret = 0; while (dividend >= divisor) { int q = 1; int d = divisor; int half = dividend >> 1; while (half >= d) { d "},"leetcode/substring-with-concatenation-of-all-words.html":{"url":"leetcode/substring-with-concatenation-of-all-words.html","title":"30.Substring with Concatenation of All Words","keywords":"","body":"30. Substring with Concatenation of All Words Difficulty: Hard Topics: Hash Table, Two Pointers, String Similar Questions: Minimum Window Substring Problem: You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] Solutions: class Solution { public: vector findSubstring(string s, vector& words) { int n = words.size(); if (n == 0) return {}; int wordLen = words[0].length(); int strLen = s.length(); if (strLen ret; unordered_map> hashToIndex; for (int i = 0; i RobinHash(strLen - wordLen + 1, 0); int runningHash = 0; for (int i = 0; i seen; bool stop = false; int count = 0; for (int j = 0; j hashToIndex[h].size()) { stop = true; break; } ++count; // count is after if } } if (count == n) { ret.push_back(i); } } return ret; } int hash(string s) { int ret = 0; for (auto c : s) { ret = (ret * MAGIC + c - 'a') % MOD; } return ret; } private: int MAGIC = 31; int MOD = INT_MAX/MAGIC; }; "},"leetcode/next-permutation.html":{"url":"leetcode/next-permutation.html","title":"31.Next Permutation","keywords":"","body":"31. Next Permutation Difficulty: Medium Topics: Array Similar Questions: Permutations Permutations II Permutation Sequence Palindrome Permutation II Problem: Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Solutions: class Solution { public: void nextPermutation(vector& nums) { if (nums.size() == 0) return; int i = 0; for (i = nums.size() - 2; i >= 0; --i) { if (nums[i] = 0) { int j = nums.size() - 1; while (j >= 0 && nums[j] & nums, int start, int end) { while (start "},"leetcode/longest-valid-parentheses.html":{"url":"leetcode/longest-valid-parentheses.html","title":"32.Longest Valid Parentheses","keywords":"","body":"32. Longest Valid Parentheses Difficulty: Hard Topics: String, Dynamic Programming Similar Questions: Valid Parentheses Problem: Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" Solutions: class Solution { //gready method need to consider two scenarios public: int longestValidParentheses(string s) { string reversed = s; reverse(reversed.begin(), reversed.end()); replace(reversed.begin(), reversed.end(), '(', '='); replace(reversed.begin(), reversed.end(), ')', '('); replace(reversed.begin(), reversed.end(), '=', ')'); return max(longestValidParenthesesHelper(s), longestValidParenthesesHelper(reversed)); } int longestValidParenthesesHelper(string s) { int ret = 0; int balance = 0; int left = 0; for (int i = 0; i "},"leetcode/search-in-rotated-sorted-array.html":{"url":"leetcode/search-in-rotated-sorted-array.html","title":"33.Search in Rotated Sorted Array","keywords":"","body":"33. Search in Rotated Sorted Array Difficulty: Medium Topics: Array, Binary Search Similar Questions: Search in Rotated Sorted Array II Find Minimum in Rotated Sorted Array Problem: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Solutions: class Solution { public: /** * @param A: an integer rotated sorted array * @param target: an integer to be searched * @return: an integer */ int search(vector &A, int target) { // write your code here if (A.size() == 0) return -1; int left = 0; int right = A.size() - 1; while (left + 1 > 1); if (A[mid] == target) return mid; if (A[left] A[left]) { if (A[mid] > target && A[left] = target) { left = mid; } else { right = mid; } } } } if (A[left] == target) return left; if (A[right] == target) return right; return -1; } }; "},"leetcode/find-first-and-last-position-of-element-in-sorted-array.html":{"url":"leetcode/find-first-and-last-position-of-element-in-sorted-array.html","title":"34.Find First and Last Position of Element in Sorted Array","keywords":"","body":"34. Find First and Last Position of Element in Sorted Array Difficulty: Medium Topics: Array, Binary Search Similar Questions: First Bad Version Problem: Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Solutions: bool searchLeft(vector& nums, int index, int target) { return nums[index] >= target; } bool searchRight(vector& nums, int index, int target) { return nums[index] > target || index == nums.size() - 1 || (nums[index] == target && nums[index + 1] > target); } class Solution { public: typedef bool (*check) (vector&, int, int); vector searchRange(vector& nums, int target) { if (nums.size() == 0) return {-1, -1}; int leftBound = search(nums, 0, nums.size() - 1, target, &searchLeft); int rightBound = search(nums, 0, nums.size() - 1, target, &searchRight); return {nums[leftBound] == target ? leftBound : - 1, nums[rightBound] == target ? rightBound : - 1}; } int search(vector& nums, int left, int right, int target, check fn) { while (left "},"leetcode/search-insert-position.html":{"url":"leetcode/search-insert-position.html","title":"35.Search Insert Position","keywords":"","body":"35. Search Insert Position Difficulty: Easy Topics: Array, Binary Search Similar Questions: First Bad Version Problem: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 Solutions: class Solution { public: int searchInsert(vector& nums, int target) { int left = 0; int right = nums.size() - 1; while (left = target) { right = mid; } else { left = mid + 1; } } return nums[left] >= target ? left : left + 1; } }; "},"leetcode/valid-sudoku.html":{"url":"leetcode/valid-sudoku.html","title":"36.Valid Sudoku","keywords":"","body":"36. Valid Sudoku Difficulty: Medium Topics: Hash Table Similar Questions: Sudoku Solver Problem: Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: true Example 2: Input: [   [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],   [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],   [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],   [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],   [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],   [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],   [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],   [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],   [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9. Solutions: class Solution { public: bool isValidSudoku(vector>& board) { int m = board.size(); if (m == 0) return true; for (int i = 0; i >& board, int row) { bool nums[10] = {false}; for (auto c : board[row]) { if (c == '.') continue; if (nums[c - '0']) return false; nums[c - '0'] = true; } return true; } bool isColumnValid(vector>& board, int col) { bool nums[10] = {false}; int rowNum = board.size(); for (int i = 0; i >& board, int row, int col) { bool nums[10] = {false}; for (int i = row; i "},"leetcode/sudoku-solver.html":{"url":"leetcode/sudoku-solver.html","title":"37.Sudoku Solver","keywords":"","body":"37. Sudoku Solver Difficulty: Hard Topics: Hash Table, Backtracking Similar Questions: Valid Sudoku Unique Paths III Problem: Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character '.'. A sudoku puzzle... ...and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. Solutions: class Solution { public: void solveSudoku(vector>& board) { int n = 9; vector> rows (n, vector (n, false)); vector> cols (n, vector (n, false)); vector>> blocks (3, vector>(3, vector (n, false))); for (int i = 0; i >& board, int n, int row, int col, vector>& rows, vector>& cols, vector>>& blocks) { for (int i = row; i >& rows, vector>& cols, vector>>& blocks, int row, int col, int val) { return rows[row][val-1] == false && cols[col][val-1] == false && blocks[row/3][col/3][val-1] == false; } }; "},"leetcode/count-and-say.html":{"url":"leetcode/count-and-say.html","title":"38.Count and Say","keywords":"","body":"38. Count and Say Difficulty: Easy Topics: String Similar Questions: Encode and Decode Strings String Compression Problem: The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, then one 1\" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: \"1\" Example 2: Input: 4 Output: \"1211\" Solutions: class Solution { public: string countAndSay(int n) { if (n == 1) return \"1\"; string last = countAndSay(n - 1); string ret; char prev = last[0]; int count = 0; for (auto c : last) { if (c == prev) { ++count; } else { ret.push_back(count + '0'); ret.push_back(prev); count = 1; prev = c; } } if (count > 0) { ret.push_back(count + '0'); ret.push_back(prev); } return ret; } }; "},"leetcode/combination-sum.html":{"url":"leetcode/combination-sum.html","title":"39.Combination Sum","keywords":"","body":"39. Combination Sum Difficulty: Medium Topics: Array, Backtracking Similar Questions: Letter Combinations of a Phone Number Combination Sum II Combinations Combination Sum III Factor Combinations Combination Sum IV Problem: Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ] Solutions: class Solution { public: vector> combinationSum(vector& candidates, int target) { sort(candidates.begin(), candidates.end()); vector path; vector> ret; helper(candidates, 0, target, path, ret); unique(ret.begin(), ret.end()); return ret; } void helper(vector& candidates, int pos, int target, vector& path, vector>& ret) { if (target "},"leetcode/combination-sum-ii.html":{"url":"leetcode/combination-sum-ii.html","title":"40.Combination Sum II","keywords":"","body":"40. Combination Sum II Difficulty: Medium Topics: Array, Backtracking Similar Questions: Combination Sum Problem: Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ] Solutions: class Solution { public: vector> combinationSum2(vector& candidates, int target) { sort(candidates.begin(), candidates.end()); vector path; vector> ret; helper(candidates, 0, target, path, ret); return ret; } void helper(vector& candidates, int pos, int target, vector& path, vector>& ret) { if (target "},"leetcode/first-missing-positive.html":{"url":"leetcode/first-missing-positive.html","title":"41.First Missing Positive","keywords":"","body":"41. First Missing Positive Difficulty: Hard Topics: Array Similar Questions: Missing Number Find the Duplicate Number Find All Numbers Disappeared in an Array Couples Holding Hands Problem: Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Solutions: class Solution { public: int firstMissingPositive(vector& nums) { int n = nums.size(); for (int i = 0; i = 1 && pendingVal "},"leetcode/trapping-rain-water.html":{"url":"leetcode/trapping-rain-water.html","title":"42.Trapping Rain Water","keywords":"","body":"42. Trapping Rain Water Difficulty: Hard Topics: Array, Two Pointers, Stack Similar Questions: Container With Most Water Product of Array Except Self Trapping Rain Water II Pour Water Problem: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Solutions: class Solution { public: int trap(vector& height) { int ret = 0; int leftHeight = 0; int rightHeight = 0; int left = 0; int right = height.size() - 1; while (left 0) ret += leftHeight - height[left]; leftHeight = max(leftHeight, height[left]); ++left; } else { if (rightHeight - height[right] > 0) { if (rightHeight - height[right] > 0) ret += rightHeight - height[right]; } rightHeight = max(rightHeight, height[right]); --right; } } return ret; } }; "},"leetcode/multiply-strings.html":{"url":"leetcode/multiply-strings.html","title":"43.Multiply Strings","keywords":"","body":"43. Multiply Strings Difficulty: Medium Topics: Math, String Similar Questions: Add Two Numbers Plus One Add Binary Add Strings Problem: Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = \"2\", num2 = \"3\" Output: \"6\" Example 2: Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" Note: The length of both num1 and num2 is Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. Solutions: class Solution { public: string multiply(string num1, string num2) { int len1 = num1.length(); int len2 = num2.length(); if (num1 == \"0\" || num2 == \"0\") return \"0\"; // this check is important vector digits (len1 + len2, 0); for (int i = 0; i 0; --i) { int digit = digits[i] % 10; digits[i-1] += digits[i]/10; ret.push_back(digit + '0'); } if (digits[0] > 0) ret.push_back(digits[0] + '0'); reverse(ret.begin(), ret.end()); return ret; } }; "},"leetcode/wildcard-matching.html":{"url":"leetcode/wildcard-matching.html","title":"44.Wildcard Matching","keywords":"","body":"44. Wildcard Matching Difficulty: Hard Topics: String, Dynamic Programming, Backtracking, Greedy Similar Questions: Regular Expression Matching Problem: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"*\" Output: true Explanation: '*' matches any sequence. Example 3: Input: s = \"cb\" p = \"?a\" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Example 4: Input: s = \"adceb\" p = \"*a*b\" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\". Example 5: Input: s = \"acdcb\" p = \"a*c?b\" Output: false Solutions: class Solution { public boolean isMatch(String s, String p) { int slen= s.length(); int plen= p.length(); boolean[][] dp=new boolean[plen+1][slen+1]; Arrays.fill(dp[0],false); dp[0][0]=true; for(int i=0;i "},"leetcode/jump-game-ii.html":{"url":"leetcode/jump-game-ii.html","title":"45.Jump Game II","keywords":"","body":"45. Jump Game II Difficulty: Hard Topics: Array, Greedy Similar Questions: Jump Game Problem: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. Solutions: class Solution { public: int jump(vector& nums) { int start = 0; int reachable = 0; int count = 0; for (;;) { if (reachable >= nums.size() - 1) return count; int nextReachable = 0; for (int i = start; i "},"leetcode/permutations.html":{"url":"leetcode/permutations.html","title":"46.Permutations","keywords":"","body":"46. Permutations Difficulty: Medium Topics: Backtracking Similar Questions: Next Permutation Permutations II Permutation Sequence Combinations Problem: Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] Solutions: class Solution { public: vector> permute(vector& nums) { vector> ret; vector path; helper(nums, 0, ret); return ret; } void helper(vector& nums, int pos, vector>& ret) { if (nums.size() == pos) { ret.push_back(nums); return; } for (int i = pos; i "},"leetcode/permutations-ii.html":{"url":"leetcode/permutations-ii.html","title":"47.Permutations II","keywords":"","body":"47. Permutations II Difficulty: Medium Topics: Backtracking Similar Questions: Next Permutation Permutations Palindrome Permutation II Number of Squareful Arrays Problem: Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] Solutions: class Solution { public: vector> permuteUnique(vector& nums) { //sort(nums.begin(), nums.end()); vector> ret; helper(nums, 0, ret); return ret; } void helper(vector& nums, int pos, vector>& ret) { if (pos == nums.size()) { ret.push_back(nums); return; } unordered_set seen; //Use index is not able to deduplicate. for example [0,0,1,2]. If the last element swap with the first, the list becomes [2, 0, 1, 0], which elements with the same value are not adjecent. for (int i = pos; i 0) continue; seen.insert(nums[i]); swap(nums[pos], nums[i]); helper(nums, pos + 1, ret); swap(nums[pos], nums[i]); } } }; "},"leetcode/rotate-image.html":{"url":"leetcode/rotate-image.html","title":"48.Rotate Image","keywords":"","body":"48. Rotate Image Difficulty: Medium Topics: Array Similar Questions: Problem: You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Solutions: class Solution { public: void rotate(vector>& matrix) { int n = matrix.size(); for (int i = 0; i >& matrix, int n, int row, int col) { int coord[4][2] = {{row, col}, {col, n - 1 - row}, {n - 1 - row, n - 1 - col}, {n - 1 - col,row}}; int start = 0; for (int i = 0; i "},"leetcode/group-anagrams.html":{"url":"leetcode/group-anagrams.html","title":"49.Group Anagrams","keywords":"","body":"49. Group Anagrams Difficulty: Medium Topics: Hash Table, String Similar Questions: Valid Anagram Group Shifted Strings Problem: Given an array of strings, group anagrams together. Example: Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note: All inputs will be in lowercase. The order of your output does not matter. Solutions: class Solution { public: vector> groupAnagrams(vector& strs) { unordered_map> anagrams; for (auto& str : strs) { string anagram = str; sort(anagram.begin(), anagram.end()); anagrams[anagram].push_back(str); } vector> ret; for (auto it = anagrams.begin(); it != anagrams.end(); ++it) { ret.push_back(it->second); } return ret; } }; "},"leetcode/powx-n.html":{"url":"leetcode/powx-n.html","title":"50.Pow(","keywords":"","body":"50. Pow(x, n) Difficulty: Medium Topics: Math, Binary Search Similar Questions: Sqrt(x) Super Pow Problem: Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 x n is a 32-bit signed integer, within the range [−231, 231 − 1] Solutions: class Solution { public: double myPow(double x, int n) { if (n == 0) return 1; if (n == 1) return x; if (n == -1) return 1/x; double sqrt = myPow(x, n/2); // we should not call two myPow twice! Otherwise time limit exceeds. return sqrt * sqrt * myPow(x, n - n/2 - n/2); } }; "},"leetcode/n-queens.html":{"url":"leetcode/n-queens.html","title":"51.N-Queens","keywords":"","body":"51. N-Queens Difficulty: Hard Topics: Backtracking Similar Questions: N-Queens II Grid Illumination Problem: The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. Solutions: class Solution { public: vector> solveNQueens(int n) { vector> ret; vector path; vector colVisited (n, false); helper(n, 0, path, colVisited, ret); return ret; } vector generateSolution(vector& path) { int n = path.size(); string row = string(n, '.'); vector solution; for (int i = 0; i & path) { int n = path.size(); for (int i = 0; i & path, vector& colVisited, vector>& ret) { if (n == pos) { ret.push_back(generateSolution(path)); return; } for (int i = 0; i "},"leetcode/n-queens-ii.html":{"url":"leetcode/n-queens-ii.html","title":"52.N-Queens II","keywords":"","body":"52. N-Queens II Difficulty: Hard Topics: Backtracking Similar Questions: N-Queens Problem: The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [  [\".Q..\",  // Solution 1   \"...Q\",   \"Q...\",   \"..Q.\"],  [\"..Q.\",  // Solution 2   \"Q...\",   \"...Q\",   \".Q..\"] ] Solutions: class Solution { public: int totalNQueens(int n) { int ret = 0; vector path; vector colVisited (n, false); helper(n, 0, path, colVisited, ret); return ret; } bool diagonal(int row, int col, vector& path) { int n = path.size(); for (int i = 0; i & path, vector& colVisited, int& ret) { if (n == pos) { ++ret; return; } for (int i = 0; i "},"leetcode/maximum-subarray.html":{"url":"leetcode/maximum-subarray.html","title":"53.Maximum Subarray","keywords":"","body":"53. Maximum Subarray Difficulty: Easy Topics: Array, Divide and Conquer, Dynamic Programming Similar Questions: Best Time to Buy and Sell Stock Maximum Product Subarray Degree of an Array Longest Turbulent Subarray Problem: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Solutions: class Solution { public: int maxSubArray(vector& nums) { int suffix = 0; int ret = INT_MIN; int sum = 0; for (auto num : nums) { sum += num; ret = max(ret, sum - suffix); suffix = min(suffix, sum); } return ret; } }; "},"leetcode/spiral-matrix.html":{"url":"leetcode/spiral-matrix.html","title":"54.Spiral Matrix","keywords":"","body":"54. Spiral Matrix Difficulty: Medium Topics: Array Similar Questions: Spiral Matrix II Problem: Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Solutions: class Solution { public: vector spiralOrder(vector>& matrix) { int m = matrix.size(); if (m == 0) return {}; int n = matrix[0].size(); if (n == 0) return {}; vector ret; int top = 0; int bottom = m - 1; int left = 0; int right = n - 1; int row = 0; int col = -1; int d = 0; for (;;) { // to right if (col + 1 > right) return ret; while (col bottom) return ret; while (row left) { ret.push_back(matrix[row][--col]); } --bottom; //to top if (row - 1 top) { ret.push_back(matrix[--row][col]); } ++left; } } }; "},"leetcode/jump-game.html":{"url":"leetcode/jump-game.html","title":"55.Jump Game","keywords":"","body":"55. Jump Game Difficulty: Medium Topics: Array, Greedy Similar Questions: Jump Game II Problem: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum   jump length is 0, which makes it impossible to reach the last index. Solutions: class Solution { public: bool canJump(vector& nums) { if (nums.size() == 0) return false; int distance = 0; for (int i = 0; i = nums.size() - 1) return true; } return false; } }; "},"leetcode/merge-intervals.html":{"url":"leetcode/merge-intervals.html","title":"56.Merge Intervals","keywords":"","body":"56. Merge Intervals Difficulty: Medium Topics: Array, Sort Similar Questions: Insert Interval Meeting Rooms Meeting Rooms II Teemo Attacking Add Bold Tag in String Range Module Employee Free Time Partition Labels Interval List Intersections Problem: Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solutions: class Solution { public: vector> merge(vector>& intervals) { vector> ret; sort(intervals.begin(), intervals.end()); // be careful about vector comparison for (auto& interval : intervals) { if (ret.empty() || ret.back()[1] "},"leetcode/insert-interval.html":{"url":"leetcode/insert-interval.html","title":"57.Insert Interval","keywords":"","body":"57. Insert Interval Difficulty: Hard Topics: Array, Sort Similar Questions: Merge Intervals Range Module Problem: Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solutions: class Solution { public: vector> insert(vector>& intervals, vector& newInterval) { vector> ret; int i = 0; for (; i "},"leetcode/length-of-last-word.html":{"url":"leetcode/length-of-last-word.html","title":"58.Length of Last Word","keywords":"","body":"58. Length of Last Word Difficulty: Easy Topics: String Similar Questions: Problem: Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: \"Hello World\" Output: 5   Solutions: class Solution { public: int lengthOfLastWord(string s) { int len = 0; for (int i = 0; i "},"leetcode/permutation-sequence.html":{"url":"leetcode/permutation-sequence.html","title":"60.Permutation Sequence","keywords":"","body":"60. Permutation Sequence Difficulty: Medium Topics: Math, Backtracking Similar Questions: Next Permutation Permutations Problem: The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: Input: n = 3, k = 3 Output: \"213\" Example 2: Input: n = 4, k = 9 Output: \"2314\" Solutions: class Solution { public: string getPermutation(int n, int k) { string digits = \"123456789\"; digits = digits.substr(0, n); if (n == 1) return \"1\"; int base = 1; for (int i = 1; i "},"leetcode/rotate-list.html":{"url":"leetcode/rotate-list.html","title":"61.Rotate List","keywords":"","body":"61. Rotate List Difficulty: Medium Topics: Linked List, Two Pointers Similar Questions: Rotate Array Split Linked List in Parts Problem: Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if (head == NULL) return NULL; int count = 1; ListNode* cur = head; while (cur->next) { ++count; cur = cur->next; } cur->next = head; k = k % count; cur = head; for (int i = 0; i next; } ListNode* ret = cur->next; cur->next = NULL; return ret; } }; "},"leetcode/unique-paths.html":{"url":"leetcode/unique-paths.html","title":"62.Unique Paths","keywords":"","body":"62. Unique Paths Difficulty: Medium Topics: Array, Dynamic Programming Similar Questions: Unique Paths II Minimum Path Sum Dungeon Game Problem: A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right Example 2: Input: m = 7, n = 3 Output: 28 Solutions: class Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector dp(n, 1); for (int i = 1; i "},"leetcode/unique-paths-ii.html":{"url":"leetcode/unique-paths-ii.html","title":"63.Unique Paths II","keywords":"","body":"63. Unique Paths II Difficulty: Medium Topics: Array, Dynamic Programming Similar Questions: Unique Paths Unique Paths III Problem: A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right Solutions: class Solution { public: int uniquePathsWithObstacles(vector>& obstacleGrid) { int m = obstacleGrid.size(); if (m == 0) return 0; int n = obstacleGrid[0].size(); if (n == 0) return 0; vector> dp (m, vector (n, 0)); // the type is long otherwise there is possiblity of overflow exception for intermittent positions. dp[0][0] = 1; for (int i = 0; i = 0 ? dp[i-1][j] : 0) + (j - 1 >= 0 ? dp[i][j-1] : 0); if (i == 0 && j == 0) dp[i][j] = 1; // otherwise dp[0][0] would be corrupted. } } } return dp[m-1][n-1]; } }; "},"leetcode/minimum-path-sum.html":{"url":"leetcode/minimum-path-sum.html","title":"64.Minimum Path Sum","keywords":"","body":"64. Minimum Path Sum Difficulty: Medium Topics: Array, Dynamic Programming Similar Questions: Unique Paths Dungeon Game Cherry Pickup Problem: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solutions: class Solution { public: int minPathSum(vector>& grid) { int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; vector> dp(m, vector(n, 0)); dp[0][0] = grid[0][0]; for (int i = 1; i "},"leetcode/valid-number.html":{"url":"leetcode/valid-number.html","title":"65.Valid Number","keywords":"","body":"65. Valid Number Difficulty: Hard Topics: Math, String Similar Questions: String to Integer (atoi) Problem: Validate if a given string can be interpreted as a decimal number. Some examples: \"0\" => true \" 0.1 \" => true \"abc\" => false \"1 a\" => false \"2e10\" => true \" -90e3   \" => true \" 1e\" => false \"e3\" => false \" 6e-1\" => true \" 99e2.5 \" => false \"53.5e93\" => true \" --6 \" => false \"-+3\" => false \"95a54e53\" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number: Numbers 0-9 Exponent - \"e\" Positive/negative sign - \"+\"/\"-\" Decimal point - \".\" Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Solutions: class Solution { public: bool isNumber(string s) { bool sign = false; bool dot = false; bool exponent = false; bool num = false; int left = 0; while (left = 0 && s[right] == ' ') --right; if (left > right) return false; for (int i = left; i = 0 && s[i-1] == '0' && !dot) return false; } else if (c == '+' || c == '-') { if (sign) return false; sign = true; } else if (c == 'e') { if (exponent) return false; if (!num) return false; sign = false; dot = true; exponent = true; num = false; } else if (c == '.') { if (dot) return false; dot = true; sign = true; } else { return false; } } return s[right] != 'e' && num; } }; "},"leetcode/plus-one.html":{"url":"leetcode/plus-one.html","title":"66.Plus One","keywords":"","body":"66. Plus One Difficulty: Easy Topics: Array Similar Questions: Multiply Strings Add Binary Plus One Linked List Add to Array-Form of Integer Problem: Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Solutions: class Solution { public: vector plusOne(vector& digits) { int carry = 1; for (int i = digits.size() -1; carry > 0 && i >= 0; --i) { digits[i] += carry; carry = digits[i]/10; digits[i] %= 10; } if (carry == 1) { digits.insert(digits.begin(), 1); // how to insert at head } return digits; } }; "},"leetcode/add-binary.html":{"url":"leetcode/add-binary.html","title":"67.Add Binary","keywords":"","body":"67. Add Binary Difficulty: Easy Topics: Math, String Similar Questions: Add Two Numbers Multiply Strings Plus One Add to Array-Form of Integer Problem: Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" Solutions: class Solution { public: string addBinary(string a, string b) { string ret; int carry = 0; int indexA = a.length() - 1; int indexB = b.length() - 1; while (indexA >= 0 || indexB >= 0) { int digitA = 0; int digitB = 0; if (indexA >= 0) { digitA = a[indexA--] - '0'; } if (indexB >= 0) { digitB = b[indexB--] - '0'; } int val = carry + digitA + digitB; ret.push_back('0' + val%2); carry = val/2; } if (carry == 1) ret.push_back('1'); reverse(ret.begin(), ret.end()); return ret; } }; "},"leetcode/text-justification.html":{"url":"leetcode/text-justification.html","title":"68.Text Justification","keywords":"","body":"68. Text Justification Difficulty: Hard Topics: String Similar Questions: Problem: Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note: A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word. Example 1: Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"] maxWidth = 16 Output: [    \"This    is    an\",    \"example  of text\",    \"justification.  \" ] Example 2: Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"] maxWidth = 16 Output: [   \"What   must   be\",   \"acknowledgment  \",   \"shall be        \" ] Explanation: Note that the last line is \"shall be \" instead of \"shall be\",   because the last line must be left-justified instead of fully-justified. Note that the second line is also left-justified becase it contains only one word. Example 3: Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",   \"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"] maxWidth = 20 Output: [   \"Science  is  what we\", \"understand      well\",   \"enough to explain to\",   \"a  computer.  Art is\",   \"everything  else  we\",   \"do                  \" ] Solutions: class Solution { public: vector fullJustify(vector& words, int maxWidth) { vector ret; int count = 0; int n = words.size(); vector buffer; for (int i = 0; i maxWidth) { ret.push_back(lineProcess(buffer, maxWidth)); count = 0; buffer.clear(); } else { buffer.push_back(words[i]); count += 1 + words[i].length(); ++i; } } } if (buffer.size() != 0) { ret.push_back(lastLineProcess(buffer, maxWidth)); } return ret; } string lineProcess(vector& buffer, int maxWidth) { if (buffer.size() == 1) return lastLineProcess(buffer, maxWidth); int count = 0; for (auto& word : buffer) { count += word.length(); } int quotient = (maxWidth - count) / (buffer.size() - 1); int modulo = (maxWidth - count) % (buffer.size() - 1); string ret; ret.append(buffer[0]); for (int i = 1; i 0 ? 1 : 0); ret.append(distance, ' '); ret.append(buffer[i]); } return ret; } string lastLineProcess(vector& buffer, int maxWidth) { string ret = buffer[0]; for (int i = 1; i "},"leetcode/sqrtx.html":{"url":"leetcode/sqrtx.html","title":"69.Sqrt(x)","keywords":"","body":"69. Sqrt(x) Difficulty: Easy Topics: Math, Binary Search Similar Questions: Pow(x, n) Valid Perfect Square Problem: Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since   the decimal part is truncated, 2 is returned. Solutions: class Solution { public: int mySqrt(int x) { int left = 0; int right = INT_MAX; while (left + 1 = mid) { // mid * mid = right) return right; return left; } }; "},"leetcode/climbing-stairs.html":{"url":"leetcode/climbing-stairs.html","title":"70.Climbing Stairs","keywords":"","body":"70. Climbing Stairs Difficulty: Easy Topics: Dynamic Programming Similar Questions: Min Cost Climbing Stairs Fibonacci Number N-th Tribonacci Number Problem: You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Solutions: class Solution { public: int climbStairs(int n) { int prev = 0; int ret = 1; for (int i = 1; i "},"leetcode/simplify-path.html":{"url":"leetcode/simplify-path.html","title":"71.Simplify Path","keywords":"","body":"71. Simplify Path Difficulty: Medium Topics: String, Stack Similar Questions: Problem: Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.   Example 1: Input: \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: Input: \"/a/./b/../../c/\" Output: \"/c\" Example 5: Input: \"/a/../../b/../c//.//\" Output: \"/c\" Example 6: Input: \"/a//b////c/d//././/..\" Output: \"/a/b/c\" Solutions: class Solution { public: string simplifyPath(string path) { path.push_back('/'); // an elegant solution for last element deque dq; // deque is more appropriate than stack because the result need queue-like access. string directory; for (int i = 0; i "},"leetcode/edit-distance.html":{"url":"leetcode/edit-distance.html","title":"72.Edit Distance","keywords":"","body":"72. Edit Distance Difficulty: Hard Topics: String, Dynamic Programming Similar Questions: One Edit Distance Delete Operation for Two Strings Minimum ASCII Delete Sum for Two Strings Uncrossed Lines Problem: Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Solutions: class Solution { public: int minDistance(string word1, string word2) { int len1 = word1.length(); int len2 = word2.length(); vector> dp(1 + len1, vector (1 + len2, 0)); for (int i = 0 ; i "},"leetcode/set-matrix-zeroes.html":{"url":"leetcode/set-matrix-zeroes.html","title":"73.Set Matrix Zeroes","keywords":"","body":"73. Set Matrix Zeroes Difficulty: Medium Topics: Array Similar Questions: Game of Life Problem: Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input: [   [1,1,1],   [1,0,1],   [1,1,1] ] Output: [   [1,0,1],   [0,0,0],   [1,0,1] ] Example 2: Input: [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output: [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Solutions: class Solution { public: void setZeroes(vector>& matrix) { int m = matrix.size(); if (m == 0) return; int n = matrix[0].size(); if (n == 0) return; bool firstRowSet = false; bool firstColSet = false; for (int i = 0; i "},"leetcode/search-a-2d-matrix.html":{"url":"leetcode/search-a-2d-matrix.html","title":"74.Search a 2D Matrix","keywords":"","body":"74. Search a 2D Matrix Difficulty: Medium Topics: Array, Binary Search Similar Questions: Search a 2D Matrix II Problem: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false Solutions: class Solution { public: bool searchMatrix(vector>& matrix, int target) { int m = matrix.size(); if (m == 0) return false; int n = matrix[0].size(); if (n == 0) return false; int left = 0; int right = m * n - 1; while (left target) { right = mid - 1; } else { left = mid + 1; } } return false; } inline pair arrayToMatrix(int m, int n, int index) { return {index/n, index%n}; } }; "},"leetcode/sort-colors.html":{"url":"leetcode/sort-colors.html","title":"75.Sort Colors","keywords":"","body":"75. Sort Colors Difficulty: Medium Topics: Array, Two Pointers, Sort Similar Questions: Sort List Wiggle Sort Wiggle Sort II Problem: Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? Solutions: class Solution { public: void sortColors(vector& nums) { int left = 0; int right = nums.size() - 1; for (int i = left; i "},"leetcode/minimum-window-substring.html":{"url":"leetcode/minimum-window-substring.html","title":"76.Minimum Window Substring","keywords":"","body":"76. Minimum Window Substring Difficulty: Hard Topics: Hash Table, Two Pointers, String, Sliding Window Similar Questions: Substring with Concatenation of All Words Minimum Size Subarray Sum Sliding Window Maximum Permutation in String Smallest Range Covering Elements from K Lists Minimum Window Subsequence Problem: Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Solutions: class Solution { public: string minWindow(string s, string t) { unordered_map charCount; for (auto c : t) { ++charCount[c]; } int r = 0; int l = 0; int count = t.length(); string ret; int len = INT_MAX; for (r = 0; r = 0) --count; if (charCount[c] == 0 && count == 0) { while (true) { if (charCount.count(s[l]) == 0) { ++l; } else { char lastC = s[l]; ++l; ++charCount[lastC]; if (charCount[lastC] == 1) { ++count; break; } } } if (r - l + 2 "},"leetcode/combinations.html":{"url":"leetcode/combinations.html","title":"77.Combinations","keywords":"","body":"77. Combinations Difficulty: Medium Topics: Backtracking Similar Questions: Combination Sum Permutations Problem: Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Solutions: class Solution { public: vector> combine(int n, int k) { vector path; vector> ret; helper(n, k, 1, path, ret); return ret; } void helper(int n, int k, int pos, vector& path, vector>& ret) { if (path.size() == k) { ret.push_back(path); return; } if (pos > n || n - pos + 1 + path.size() "},"leetcode/subsets.html":{"url":"leetcode/subsets.html","title":"78.Subsets","keywords":"","body":"78. Subsets Difficulty: Medium Topics: Array, Backtracking, Bit Manipulation Similar Questions: Subsets II Generalized Abbreviation Letter Case Permutation Problem: Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ] Solutions: class Solution { public: vector> subsets(vector& nums) { vector> ret; vector path; helper(nums, 0, path, ret); return ret; } void helper(vector& nums, int pos, vector& path, vector>& ret) { if (pos == nums.size()) { ret.push_back(path); return; } path.push_back(nums[pos]); helper(nums, pos + 1, path, ret); path.pop_back(); helper(nums, pos + 1, path, ret); } }; "},"leetcode/word-search.html":{"url":"leetcode/word-search.html","title":"79.Word Search","keywords":"","body":"79. Word Search Difficulty: Medium Topics: Array, Backtracking Similar Questions: Word Search II Problem: Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \"ABCCED\", return true. Given word = \"SEE\", return true. Given word = \"ABCB\", return false. Solutions: class Solution { public: bool exist(vector>& board, string word) { if (word.length() == 0) return true; int m = board.size(); if (m == 0) return false; int n = board[0].size(); if (n == 0) return false; // there is on path! vector> visited (m, vector(n, false)); for (int i = 0; i >& board, int m, int n, int i, int j, vector>& visited, string& word, int pos) { if (i = m || j = n || visited[i][j]) return false; if (word[pos] != board[i][j]) return false; visited[i][j] = true; if (pos == word.length() - 1) return true; for (int d = 0; d "},"leetcode/remove-duplicates-from-sorted-array-ii.html":{"url":"leetcode/remove-duplicates-from-sorted-array-ii.html","title":"80.Remove Duplicates from Sorted Array II","keywords":"","body":"80. Remove Duplicates from Sorted Array II Difficulty: Medium Topics: Array, Two Pointers Similar Questions: Remove Duplicates from Sorted Array Problem: Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i Solutions: class Solution { public: int removeDuplicates(vector& nums) { int cur = 0; for (int i = 0; i "},"leetcode/search-in-rotated-sorted-array-ii.html":{"url":"leetcode/search-in-rotated-sorted-array-ii.html","title":"81.Search in Rotated Sorted Array II","keywords":"","body":"81. Search in Rotated Sorted Array II Difficulty: Medium Topics: Array, Binary Search Similar Questions: Search in Rotated Sorted Array Problem: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? Solutions: class Solution { public: bool search(vector& nums, int target) { return helper(nums, 0, nums.size() - 1, target); } bool helper(vector& nums, int left, int right, int target) { if (left > right) return false; if (left == right) return nums[left] == target; int mid = left + (right - left)/2; if (nums[left] == nums[right] && nums[left] == nums[mid]) { return helper(nums, left, mid, target) || helper(nums, mid + 1, right, target); } else { if (nums[left] = nums[left]) { if (target nums[mid]) return helper(nums, mid + 1, right, target); else return helper(nums, left, mid, target); } else { if (target > nums[mid] && target "},"leetcode/remove-duplicates-from-sorted-list-ii.html":{"url":"leetcode/remove-duplicates-from-sorted-list-ii.html","title":"82.Remove Duplicates from Sorted List II","keywords":"","body":"82. Remove Duplicates from Sorted List II Difficulty: Medium Topics: Linked List Similar Questions: Remove Duplicates from Sorted List Problem: Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* dummyHead = new ListNode(0); ListNode* tail = dummyHead; ListNode* cur = head; while (cur) { if (cur->next && cur->val == cur->next->val) { int val = cur->val; cur = cur->next->next; while (cur && cur->val == val) { cur = cur->next; } } else { tail->next = cur; tail = cur; cur = cur->next; } } tail->next = NULL; return dummyHead->next; } }; "},"leetcode/remove-duplicates-from-sorted-list.html":{"url":"leetcode/remove-duplicates-from-sorted-list.html","title":"83.Remove Duplicates from Sorted List","keywords":"","body":"83. Remove Duplicates from Sorted List Difficulty: Easy Topics: Linked List Similar Questions: Remove Duplicates from Sorted List II Problem: Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* cur = head; while (cur && cur->next) { if (cur->val == cur->next->val) { cur->next = cur->next->next; } else { cur = cur->next; } } return head; } }; "},"leetcode/largest-rectangle-in-histogram.html":{"url":"leetcode/largest-rectangle-in-histogram.html","title":"84.Largest Rectangle in Histogram","keywords":"","body":"84. Largest Rectangle in Histogram Difficulty: Hard Topics: Array, Stack Similar Questions: Maximal Rectangle Problem: Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.   Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].   The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10 Solutions: class Solution { public: int largestRectangleArea(vector& heights) { heights.push_back(0); stack stk; int area = 0; for (int i = 0; i heights[i]) { int topIndex = stk.top(); stk.pop(); area = max(area, heights[topIndex] * (i - (stk.empty() ? 0 : stk.top() + 1))); //cout "},"leetcode/maximal-rectangle.html":{"url":"leetcode/maximal-rectangle.html","title":"85.Maximal Rectangle","keywords":"","body":"85. Maximal Rectangle Difficulty: Hard Topics: Array, Hash Table, Dynamic Programming, Stack Similar Questions: Largest Rectangle in Histogram Maximal Square Problem: Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [ [\"1\",\"0\",\"1\",\"0\",\"0\"], [\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"], [\"1\",\"0\",\"0\",\"1\",\"0\"] ] Output: 6 Solutions: class Solution { public: int maximalRectangle(vector>& matrix) { int m = matrix.size(); if (m == 0) return 0; int n = matrix[0].size(); if (n == 0) return 0; vector heights (n + 1, 0); int ret = 0; for (int row = 0; row & heights) { heights.back() = 0; stack stk; int area = 0; for (int i = 0; i heights[i]) { int topIndex = stk.top(); stk.pop(); area = max(area, heights[topIndex] * (i - (stk.empty() ? 0 : (stk.top() + 1)))); } stk.push(i); } return area; } }; "},"leetcode/partition-list.html":{"url":"leetcode/partition-list.html","title":"86.Partition List","keywords":"","body":"86. Partition List Difficulty: Medium Topics: Linked List, Two Pointers Similar Questions: Problem: Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { ListNode* left = new ListNode(0); ListNode* right = new ListNode(0); ListNode* leftTail = left; ListNode* rightTail = right; while (head) { if (head->val next = head; leftTail = head; } else { rightTail->next = head; rightTail = head; } head = head->next; } leftTail->next = right->next; rightTail->next = nullptr; return left->next; } }; "},"leetcode/merge-sorted-array.html":{"url":"leetcode/merge-sorted-array.html","title":"88.Merge Sorted Array","keywords":"","body":"88. Merge Sorted Array Difficulty: Easy Topics: Array, Two Pointers Similar Questions: Merge Two Sorted Lists Squares of a Sorted Array Interval List Intersections Problem: Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Solutions: class Solution { public: void merge(vector& nums1, int m, vector& nums2, int n) { nums1.resize(m + n); int cur = m + n - 1; int i1 = m - 1; int i2 = n - 1; while (i1 >= 0 || i2 >= 0) { if (i1 = nums2[i2]) { nums1[cur--] = nums1[i1--]; } else { nums1[cur--] = nums2[i2--]; } } } } }; "},"leetcode/gray-code.html":{"url":"leetcode/gray-code.html","title":"89.Gray Code","keywords":"","body":"89. Gray Code Difficulty: Medium Topics: Backtracking Similar Questions: 1-bit and 2-bit Characters Problem: The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence. 00 - 0 10 - 2 11 - 3 01 - 1 Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.   A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.   Therefore, for n = 0 the gray code sequence is [0]. Solutions: class Solution { public: vector grayCode(int n) { if (n ret = {0}; for (int i = 0; i = 0; --j) { ret.push_back(ret[j] + (1 "},"leetcode/subsets-ii.html":{"url":"leetcode/subsets-ii.html","title":"90.Subsets II","keywords":"","body":"90. Subsets II Difficulty: Medium Topics: Array, Backtracking Similar Questions: Subsets Problem: Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solutions: class Solution { public: vector> subsetsWithDup(vector& nums) { sort(nums.begin(), nums.end()); vector path; vector> ret; helper(nums, 0, path, ret); return ret; } void helper(vector& nums, int pos, vector& path, vector>& ret) { if (pos == nums.size()) { ret.push_back(path); return; } path.push_back(nums[pos]); helper(nums, pos + 1, path, ret); path.pop_back(); while (pos + 1 "},"leetcode/decode-ways.html":{"url":"leetcode/decode-ways.html","title":"91.Decode Ways","keywords":"","body":"91. Decode Ways Difficulty: Medium Topics: String, Dynamic Programming Similar Questions: Decode Ways II Problem: A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: \"12\" Output: 2 Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: \"226\" Output: 3 Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Solutions: class Solution { public: int numDecodings(string s) { int len = s.length(); vector cache(len, -1); return helper(s, 0, cache); } int helper(string s, int pos, vector& cache) { if (pos > s.length()) return 0; if (pos == s.length()) return 1; if (cache[pos] != -1) return cache[pos]; int count = 0; if (s[pos] == '0') return 0; count += helper(s, pos + 1, cache); if (pos + 1 "},"leetcode/reverse-linked-list-ii.html":{"url":"leetcode/reverse-linked-list-ii.html","title":"92.Reverse Linked List II","keywords":"","body":"92. Reverse Linked List II Difficulty: Medium Topics: Linked List Similar Questions: Reverse Linked List Problem: Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { if (head == nullptr) return nullptr; ListNode* dummy = new ListNode(0); dummy->next = head; ListNode* cur = dummy; int index = 0; while (cur && index next; ++index; } ListNode* tail = cur; cur = cur->next; ListNode* reverseLast = cur; tail->next = nullptr; for (int i = 0; i next; cur->next = tail->next; tail->next = cur; cur = next; } reverseLast->next = cur; return dummy->next; } }; "},"leetcode/binary-tree-inorder-traversal.html":{"url":"leetcode/binary-tree-inorder-traversal.html","title":"94.Binary Tree Inorder Traversal","keywords":"","body":"94. Binary Tree Inorder Traversal Difficulty: Medium Topics: Hash Table, Stack, Tree Similar Questions: Validate Binary Search Tree Binary Tree Preorder Traversal Binary Tree Postorder Traversal Binary Search Tree Iterator Kth Smallest Element in a BST Closest Binary Search Tree Value II Inorder Successor in BST Convert Binary Search Tree to Sorted Doubly Linked List Minimum Distance Between BST Nodes Problem: Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector inorderTraversal(TreeNode* root) { vector ret; TreeNode* cur = root; while (cur) { TreeNode* pre = cur->left; if (pre == nullptr) { ret.push_back(cur->val); // visit cur = cur->right; continue; } while (pre->right != nullptr && pre->right != cur) { pre = pre->right; } if (pre->right == nullptr) { pre->right = cur; cur = cur->left; } else { pre->right = nullptr; ret.push_back(cur->val); // visit cur = cur->right; } } return ret; } }; "},"leetcode/unique-binary-search-trees-ii.html":{"url":"leetcode/unique-binary-search-trees-ii.html","title":"95.Unique Binary Search Trees II","keywords":"","body":"95. Unique Binary Search Trees II Difficulty: Medium Topics: Dynamic Programming, Tree Similar Questions: Unique Binary Search Trees Different Ways to Add Parentheses Problem: Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector generateTrees(int n) { if (n , vector> cache; return helper(1, n, cache); } vector helper(int left, int right, map, vector>& cache) { if (left > right) return {nullptr}; if (left == right) return {new TreeNode(left)}; auto range = make_pair(left, right); if (cache.count(range) > 0) return cache[range]; vector ret; for (int rootVal = left; rootVal leftRoots = helper(left, rootVal - 1, cache); vector rightRoots = helper(rootVal + 1, right, cache); for (auto leftRoot : leftRoots) { for (auto rightRoot : rightRoots) { TreeNode* root = new TreeNode(rootVal); root->left = leftRoot; root->right = rightRoot; ret.push_back(root); } } } cache[range] = ret; return ret; } }; "},"leetcode/unique-binary-search-trees.html":{"url":"leetcode/unique-binary-search-trees.html","title":"96.Unique Binary Search Trees","keywords":"","body":"96. Unique Binary Search Trees Difficulty: Medium Topics: Dynamic Programming, Tree Similar Questions: Unique Binary Search Trees II Problem: Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Solutions: class Solution { public: int numTrees(int n) { map, int> cache; return helper(1, n, cache); } int helper(int left, int right, map, int>& cache) { if (left > right) return 1; // return 1! if (left == right) return 1; auto range = make_pair(left, right); if (cache.count(range) != 0) return cache[range]; int count = 0; for (int num = left; num "},"leetcode/interleaving-string.html":{"url":"leetcode/interleaving-string.html","title":"97.Interleaving String","keywords":"","body":"97. Interleaving String Difficulty: Hard Topics: String, Dynamic Programming Similar Questions: Problem: Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" Output: true Example 2: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" Output: false Solutions: class Solution { public: bool isInterleave(string s1, string s2, string s3) { if (s3.length() != s1.length() + s2.length()) return false; int len1 = s1.length(); int len2 = s2.length(); vector> dp (len1 + 1, vector(len2 + 1, false)); dp[0][0] = true; for (int i = 1; i "},"leetcode/validate-binary-search-tree.html":{"url":"leetcode/validate-binary-search-tree.html","title":"98.Validate Binary Search Tree","keywords":"","body":"98. Validate Binary Search Tree Difficulty: Medium Topics: Tree, Depth-first Search Similar Questions: Binary Tree Inorder Traversal Find Mode in Binary Search Tree Problem: Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.   Example 1: 2 / \\ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \\ 1 4   / \\   3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { return isValidBSTHelper(root, NULL, NULL); } bool isValidBSTHelper(TreeNode* root, TreeNode*left, TreeNode* right) { if (root == NULL) return true; if (left && root->val val || right && root->val >= right->val) return false; return isValidBSTHelper(root->left, left, root) && isValidBSTHelper(root->right, root, right); } }; "},"leetcode/same-tree.html":{"url":"leetcode/same-tree.html","title":"100.Same Tree","keywords":"","body":"100. Same Tree Difficulty: Easy Topics: Tree, Depth-first Search Similar Questions: Problem: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == nullptr && q == nullptr) return true; if (p == nullptr || q == nullptr) return false; if (p->val != q->val) return false; return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); } }; "},"leetcode/symmetric-tree.html":{"url":"leetcode/symmetric-tree.html","title":"101.Symmetric Tree","keywords":"","body":"101. Symmetric Tree Difficulty: Easy Topics: Tree, Depth-first Search, Breadth-first Search Similar Questions: Problem: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3   But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3   Note: Bonus points if you could solve it both recursively and iteratively. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return isSymmetricHelper(root->left, root->right); } bool isSymmetricHelper(TreeNode* left, TreeNode* right) { if (left == NULL && right == NULL) return true; if (left == NULL || right == NULL) return false; if (left->val != right->val) return false; return isSymmetricHelper(left->left, right->right) && isSymmetricHelper(left->right, right->left); } }; "},"leetcode/binary-tree-level-order-traversal.html":{"url":"leetcode/binary-tree-level-order-traversal.html","title":"102.Binary Tree Level Order Traversal","keywords":"","body":"102. Binary Tree Level Order Traversal Difficulty: Medium Topics: Tree, Breadth-first Search Similar Questions: Binary Tree Zigzag Level Order Traversal Binary Tree Level Order Traversal II Minimum Depth of Binary Tree Binary Tree Vertical Order Traversal Average of Levels in Binary Tree N-ary Tree Level Order Traversal Cousins in Binary Tree Problem: Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector> levelOrder(TreeNode* root) { vector> ret; if (root == NULL) return ret; queue q; q.push(root); while (!q.empty()) { int count = 0; vector level; for (int i = q.size() - 1; i >= 0; --i) { // starting from 0 is wrong because q.size() keeps on changing. auto node = q.front(); q.pop(); level.push_back(node->val); if (node->left) { q.push(node->left); } if (node->right) { q.push(node->right); } } ret.push_back(level); } return ret; } }; "},"leetcode/binary-tree-zigzag-level-order-traversal.html":{"url":"leetcode/binary-tree-zigzag-level-order-traversal.html","title":"103.Binary Tree Zigzag Level Order Traversal","keywords":"","body":"103. Binary Tree Zigzag Level Order Traversal Difficulty: Medium Topics: Stack, Tree, Breadth-first Search Similar Questions: Binary Tree Level Order Traversal Problem: Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector> zigzagLevelOrder(TreeNode* root) { vector> ret; if (root == NULL) return ret; bool forward = true; queue q; q.push(root); while (!q.empty()) { int n = q.size(); vector level(n); for (int i = 0; i left) q.push(node->left); if (node->right) q.push(node->right); if (forward) { level[i] = node->val; } else { level[n - 1 - i] = node->val; } } ret.push_back(level); forward = !forward; } return ret; } }; "},"leetcode/maximum-depth-of-binary-tree.html":{"url":"leetcode/maximum-depth-of-binary-tree.html","title":"104.Maximum Depth of Binary Tree","keywords":"","body":"104. Maximum Depth of Binary Tree Difficulty: Easy Topics: Tree, Depth-first Search Similar Questions: Balanced Binary Tree Minimum Depth of Binary Tree Maximum Depth of N-ary Tree Problem: Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its depth = 3. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + std::max(maxDepth(root->left), maxDepth(root->right)); } }; "},"leetcode/construct-binary-tree-from-preorder-and-inorder-traversal.html":{"url":"leetcode/construct-binary-tree-from-preorder-and-inorder-traversal.html","title":"105.Construct Binary Tree from Preorder and Inorder Traversal","keywords":"","body":"105. Construct Binary Tree from Preorder and Inorder Traversal Difficulty: Medium Topics: Array, Tree, Depth-first Search Similar Questions: Construct Binary Tree from Inorder and Postorder Traversal Problem: Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTree(vector& preorder, vector& inorder) { return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); } TreeNode* helper(vector& preorder, int preorderLeft, int preorderRight, vector& inorder, int inorderLeft, int inorderRight) { if (preorderRight left = helper(preorder, preorderLeft + 1, preorderLeft + 1 + leftLen - 1, inorder, inorderLeft, pos - 1); root->right = helper(preorder, preorderLeft + 1 + leftLen, preorderRight, inorder, pos + 1, inorderRight); return root; } }; "},"leetcode/construct-binary-tree-from-inorder-and-postorder-traversal.html":{"url":"leetcode/construct-binary-tree-from-inorder-and-postorder-traversal.html","title":"106.Construct Binary Tree from Inorder and Postorder Traversal","keywords":"","body":"106. Construct Binary Tree from Inorder and Postorder Traversal Difficulty: Medium Topics: Array, Tree, Depth-first Search Similar Questions: Construct Binary Tree from Preorder and Inorder Traversal Problem: Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTree(vector& inorder, vector& postorder) { return helper(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); } TreeNode* helper(vector& inorder, int inorderLeft, int inorderRight, vector& postorder, int postorderLeft, int postorderRight) { if (inorderRight left = helper(inorder, inorderLeft, pos - 1, postorder, postorderLeft, postorderLeft + leftLen - 1); root->right = helper(inorder, pos + 1, inorderRight, postorder, postorderLeft + leftLen, postorderRight - 1); return root; } }; "},"leetcode/binary-tree-level-order-traversal-ii.html":{"url":"leetcode/binary-tree-level-order-traversal-ii.html","title":"107.Binary Tree Level Order Traversal II","keywords":"","body":"107. Binary Tree Level Order Traversal II Difficulty: Easy Topics: Tree, Breadth-first Search Similar Questions: Binary Tree Level Order Traversal Average of Levels in Binary Tree Problem: Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector> levelOrderBottom(TreeNode* root) { vector> ret; queue q; if (root != NULL) q.push(root); while (!q.empty()) { int size = q.size(); vector level; for (int i = 0; i val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } ret.push_back(level); } reverse(ret.begin(), ret.end()); return ret; } }; "},"leetcode/convert-sorted-array-to-binary-search-tree.html":{"url":"leetcode/convert-sorted-array-to-binary-search-tree.html","title":"108.Convert Sorted Array to Binary Search Tree","keywords":"","body":"108. Convert Sorted Array to Binary Search Tree Difficulty: Easy Topics: Tree, Depth-first Search Similar Questions: Convert Sorted List to Binary Search Tree Problem: Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* sortedArrayToBST(vector& nums) { int n = nums.size(); return helper(nums, 0, n - 1); } TreeNode* helper(vector& nums, int left, int right) { if (left > right) return NULL; if (left == right) return new TreeNode(nums[left]); int mid = left + (right - left)/2; TreeNode* root = new TreeNode(nums[mid]); root->left = helper(nums, left, mid - 1); root->right = helper(nums, mid + 1, right); return root; } }; "},"leetcode/convert-sorted-list-to-binary-search-tree.html":{"url":"leetcode/convert-sorted-list-to-binary-search-tree.html","title":"109.Convert Sorted List to Binary Search Tree","keywords":"","body":"109. Convert Sorted List to Binary Search Tree Difficulty: Medium Topics: Linked List, Depth-first Search Similar Questions: Convert Sorted Array to Binary Search Tree Problem: Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* sortedListToBST(ListNode* head) { if (head == nullptr) return nullptr; int count = 0; ListNode* cur = head; while (cur) { ++count; cur = cur->next; } return helper(head, count); } TreeNode* helper(ListNode*& head, int count) { if (count == 0) return nullptr; if (count == 1) { int val = head->val; head = head->next; return new TreeNode(val); } int mid = (count+1)/2; int leftCount = mid - 1; int rightCount = count - 1 - leftCount; TreeNode* left = helper(head, leftCount); int val = head->val; head = head->next; TreeNode* root = new TreeNode(val); TreeNode* right = helper(head, rightCount); root->left = left; root->right = right; return root; } }; "},"leetcode/balanced-binary-tree.html":{"url":"leetcode/balanced-binary-tree.html","title":"110.Balanced Binary Tree","keywords":"","body":"110. Balanced Binary Tree Difficulty: Easy Topics: Tree, Depth-first Search Similar Questions: Maximum Depth of Binary Tree Problem: Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \\ 9 20 / \\ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 Return false. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isBalanced(TreeNode* root) { int height; return isBalanced(root, height); } bool isBalanced(TreeNode* root, int& height) { if (root == nullptr) { height = 0; return true; } int leftHeight; int rightHeight; if (isBalanced(root->left, leftHeight) && isBalanced(root->right, rightHeight) && abs(leftHeight - rightHeight) "},"leetcode/minimum-depth-of-binary-tree.html":{"url":"leetcode/minimum-depth-of-binary-tree.html","title":"111.Minimum Depth of Binary Tree","keywords":"","body":"111. Minimum Depth of Binary Tree Difficulty: Easy Topics: Tree, Depth-first Search, Breadth-first Search Similar Questions: Binary Tree Level Order Traversal Maximum Depth of Binary Tree Problem: Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its minimum depth = 2. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { if (root == nullptr) return 0; int ret = INT_MAX; if (root->left) { ret = min(ret, 1 + minDepth(root->left)); } if (root->right) { ret = min(ret, 1 + minDepth(root->right)); } return ret == INT_MAX ? 1 : ret; } }; "},"leetcode/path-sum.html":{"url":"leetcode/path-sum.html","title":"112.Path Sum","keywords":"","body":"112. Path Sum Difficulty: Easy Topics: Tree, Depth-first Search Similar Questions: Path Sum II Binary Tree Maximum Path Sum Sum Root to Leaf Numbers Path Sum III Path Sum IV Problem: Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int sum) { if (root == nullptr) return false; if (root->left == nullptr && root->right == nullptr) { return root->val == sum; } return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val); } }; "},"leetcode/path-sum-ii.html":{"url":"leetcode/path-sum-ii.html","title":"113.Path Sum II","keywords":"","body":"113. Path Sum II Difficulty: Medium Topics: Tree, Depth-first Search Similar Questions: Path Sum Binary Tree Paths Path Sum III Path Sum IV Problem: Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector> pathSum(TreeNode* root, int sum) { vector path; vector> ret; helper(root, sum, path, ret); return ret; } void helper(TreeNode* root, int sum, vector& path, vector>& ret) { if (root == nullptr) return; if (root->left == nullptr && root->right == nullptr) { if (sum == root->val) { path.push_back(root->val); ret.push_back(path); path.pop_back(); } return; } int val = root->val; path.push_back(val); helper(root->left, sum - val, path, ret); helper(root->right, sum - val, path, ret); path.pop_back(); return; } }; "},"leetcode/flatten-binary-tree-to-linked-list.html":{"url":"leetcode/flatten-binary-tree-to-linked-list.html","title":"114.Flatten Binary Tree to Linked List","keywords":"","body":"114. Flatten Binary Tree to Linked List Difficulty: Medium Topics: Tree, Depth-first Search Similar Questions: Flatten a Multilevel Doubly Linked List Problem: Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: void flatten(TreeNode* root) { TreeNode* dummyHead = new TreeNode(0); preorder(root, dummyHead); } void preorder(TreeNode* root, TreeNode*& tail) { if (root == NULL) return; TreeNode* left = root->left; TreeNode* right = root->right; tail->right = root; tail = tail->right; root->left = NULL; preorder(left, tail); preorder(right, tail); } }; "},"leetcode/distinct-subsequences.html":{"url":"leetcode/distinct-subsequences.html","title":"115.Distinct Subsequences","keywords":"","body":"115. Distinct Subsequences Difficulty: Hard Topics: String, Dynamic Programming Similar Questions: Problem: Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). Example 1: Input: S = \"rabbbit\", T = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from S. (The caret symbol ^ means the chosen letters) rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^ Example 2: Input: S = \"babgbag\", T = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. (The caret symbol ^ means the chosen letters) babgbag ^^ ^ babgbag ^^ ^ babgbag ^ ^^ babgbag ^ ^^ babgbag ^^^ Solutions: class Solution { public: int numDistinct(string s, string t) { int sLen = s.length(); int tLen = t.length(); vector> dp(sLen + 1, vector (tLen + 1, 0)); dp[0][0] = 1; for (int i = 1; i "},"leetcode/populating-next-right-pointers-in-each-node.html":{"url":"leetcode/populating-next-right-pointers-in-each-node.html","title":"116.Populating Next Right Pointers in Each Node","keywords":"","body":"116. Populating Next Right Pointers in Each Node Difficulty: Medium Topics: Tree, Depth-first Search Similar Questions: Populating Next Right Pointers in Each Node II Binary Tree Right Side View Problem: You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.   Example: Input: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\":{\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\":{\"$id\":\"5\",\"left\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":6},\"next\":null,\"right\":{\"$id\":\"7\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1} Output: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":{\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":6},\"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"7\",\"left\":{\"$ref\":\"5\"},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":3},\"right\":{\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"7\"},\"val\":1} Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.   Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Solutions: /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() {} Node(int _val, Node* _left, Node* _right, Node* _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public: Node* connect(Node* root) { if (root == nullptr) return root; if (root->left == nullptr && root->right == nullptr) return root; Node* rightMostNode = nullptr; if (root->left != nullptr && root->right != nullptr) { root->left->next = root->right; rightMostNode = root->right; } else if (root->left != nullptr) { rightMostNode = root->left; } else { rightMostNode = root->right; } if (root->next == nullptr) rightMostNode->next = nullptr; else { rightMostNode->next = (root->next->left ? root->next->left : root->next->right); } root->right = connect(root->right); root->left = connect(root->left); return root; } }; "},"leetcode/populating-next-right-pointers-in-each-node-ii.html":{"url":"leetcode/populating-next-right-pointers-in-each-node-ii.html","title":"117.Populating Next Right Pointers in Each Node II","keywords":"","body":"117. Populating Next Right Pointers in Each Node II Difficulty: Medium Topics: Tree, Depth-first Search Similar Questions: Populating Next Right Pointers in Each Node Problem: Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.   Example: Input: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\":{\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1} Output: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":{\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":{\"$ref\":\"5\"},\"val\":3},\"right\":{\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":1} Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.   Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Solutions: /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() {} Node(int _val, Node* _left, Node* _right, Node* _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public: Node* connect(Node* root) { if (root == nullptr) return nullptr; Node* dummyHead = new Node(0, nullptr, nullptr, nullptr); Node* nextDummyHead = new Node(0, nullptr, nullptr, nullptr); dummyHead->next = root; while (dummyHead->next != nullptr) { Node* cur = dummyHead->next; Node* nextTail = nextDummyHead; while (cur) { if (cur->left) { nextTail->next = cur->left; nextTail = nextTail->next; } if (cur->right) { nextTail->next = cur->right; nextTail = nextTail->next; } cur = cur->next; } dummyHead->next = nextDummyHead->next; nextDummyHead->next = nullptr; } return root; } }; "},"leetcode/pascals-triangle.html":{"url":"leetcode/pascals-triangle.html","title":"118.Pascal's Triangle","keywords":"","body":"118. Pascal's Triangle Difficulty: Easy Topics: Array Similar Questions: Pascal's Triangle II Problem: Given a non-negative integer numRows, generate the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Solutions: class Solution { public: vector> generate(int numRows) { vector> ret; if (numRows row (i + 1, 1); for (int j = 1; j "},"leetcode/pascals-triangle-ii.html":{"url":"leetcode/pascals-triangle-ii.html","title":"119.Pascal's Triangle II","keywords":"","body":"119. Pascal's Triangle II Difficulty: Easy Topics: Array Similar Questions: Pascal's Triangle Problem: Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space? Solutions: class Solution { public: vector getRow(int rowIndex) { vector row(rowIndex + 1); row[0] = 1; for (int i = 1; i 0; --j) { row[j] = row[j] + row[j-1]; } } return row; } }; "},"leetcode/triangle.html":{"url":"leetcode/triangle.html","title":"120.Triangle","keywords":"","body":"120. Triangle Difficulty: Medium Topics: Array, Dynamic Programming Similar Questions: Problem: Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. Solutions: class Solution { public: int minimumTotal(vector>& triangle) { if (triangle.size() == 0) return 0; int level = triangle.size(); vector dp (level, INT_MAX); dp[0] = 0; for (auto& values : triangle) { for (int i = values.size() - 1; i >= 1; --i) { dp[i] = values[i] + min(dp[i-1], dp[i]); } dp[0] = values[0] + dp[0]; } int ret = INT_MAX; for (auto bottom : dp) { ret = min(ret, bottom); } return ret; } }; "},"leetcode/best-time-to-buy-and-sell-stock.html":{"url":"leetcode/best-time-to-buy-and-sell-stock.html","title":"121.Best Time to Buy and Sell Stock","keywords":"","body":"121. Best Time to Buy and Sell Stock Difficulty: Easy Topics: Array, Dynamic Programming Similar Questions: Maximum Subarray Best Time to Buy and Sell Stock II Best Time to Buy and Sell Stock III Best Time to Buy and Sell Stock IV Best Time to Buy and Sell Stock with Cooldown Problem: Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.   Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Solutions: class Solution { public: int maxProfit(vector& prices) { int buy = INT_MAX; int profit = 0; for (auto price : prices) { buy = min(buy, price); profit = max(profit, price - buy); } return profit; } }; "},"leetcode/best-time-to-buy-and-sell-stock-ii.html":{"url":"leetcode/best-time-to-buy-and-sell-stock-ii.html","title":"122.Best Time to Buy and Sell Stock II","keywords":"","body":"122. Best Time to Buy and Sell Stock II Difficulty: Easy Topics: Array, Greedy Similar Questions: Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock III Best Time to Buy and Sell Stock IV Best Time to Buy and Sell Stock with Cooldown Best Time to Buy and Sell Stock with Transaction Fee Problem: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.   Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.   Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are   engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Solutions: class Solution { public: int maxProfit(vector& prices) { int profit = 0; for (int i = 1; i "},"leetcode/best-time-to-buy-and-sell-stock-iii.html":{"url":"leetcode/best-time-to-buy-and-sell-stock-iii.html","title":"123.Best Time to Buy and Sell Stock III","keywords":"","body":"123. Best Time to Buy and Sell Stock III Difficulty: Hard Topics: Array, Dynamic Programming Similar Questions: Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock II Best Time to Buy and Sell Stock IV Maximum Sum of 3 Non-Overlapping Subarrays Problem: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.   Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.   Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are   engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Solutions: class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); if (n == 0) return 0; vector forward(n, 0); vector backward(n, 0); int minVal = prices[0]; for (int i = 1; i = 0; --i) { backward[i] = max(backward[i + 1], maxVal - prices[i]); maxVal = max(maxVal, prices[i]); } int ret = 0; for (int i = 0; i "},"leetcode/binary-tree-maximum-path-sum.html":{"url":"leetcode/binary-tree-maximum-path-sum.html","title":"124.Binary Tree Maximum Path Sum","keywords":"","body":"124. Binary Tree Maximum Path Sum Difficulty: Hard Topics: Tree, Depth-first Search Similar Questions: Path Sum Sum Root to Leaf Numbers Path Sum IV Longest Univalue Path Problem: Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3] 1 / \\ 2 3 Output: 6 Example 2: Input: [-10,9,20,null,null,15,7]   -10    / \\   9  20     /  \\    15   7 Output: 42 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxPathSum(TreeNode* root) { int maxPathToRoot; return helper(root, maxPathToRoot); } int helper(TreeNode* root, int& maxPathToRoot) { if (root == nullptr) { maxPathToRoot = 0; return 0; } int ret = INT_MIN; int leftMaxPathToRoot = 0; int rightMaxPathToRoot = 0; if (root->left) { ret = max(ret, helper(root->left, leftMaxPathToRoot)); } if (root->right) { ret = max(ret, helper(root->right, rightMaxPathToRoot)); } maxPathToRoot = root->val + max(0, max(leftMaxPathToRoot, rightMaxPathToRoot)); return max(ret, root->val + max(0, leftMaxPathToRoot) + max(0, rightMaxPathToRoot)); } }; "},"leetcode/valid-palindrome.html":{"url":"leetcode/valid-palindrome.html","title":"125.Valid Palindrome","keywords":"","body":"125. Valid Palindrome Difficulty: Easy Topics: Two Pointers, String Similar Questions: Palindrome Linked List Valid Palindrome II Problem: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: \"A man, a plan, a canal: Panama\" Output: true Example 2: Input: \"race a car\" Output: false Solutions: class Solution { public: bool isPalindrome(string s) { int left = 0; int right = s.length() - 1; while (left = '0' && s[left] = 'a' && c = 'A' && c = '0' && c "},"leetcode/word-ladder.html":{"url":"leetcode/word-ladder.html","title":"127.Word Ladder","keywords":"","body":"127. Word Ladder Difficulty: Medium Topics: Breadth-first Search Similar Questions: Word Ladder II Minimum Genetic Mutation Problem: Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: 5 Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", return its length 5. Example 2: Input: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: 0 Explanation: The endWord \"cog\" is not in wordList, therefore no possible transformation. Solutions: class Solution { public: int ladderLength(string beginWord, string endWord, vector& wordList) { unordered_set wordSet(wordList.begin(), wordList.end()); if (wordSet.count(endWord) == 0) return 0; unordered_set q1; unordered_set q2; q1.insert(beginWord); q2.insert(endWord); int n = beginWord.length(); int level = 0; while (!(q1.empty() || q2.empty())) { ++level; int size1 = q1.size(); int size2 = q2.size(); if (size1 > size2) { swap(q1, q2); } unordered_set q; for (string word : q1) { if (q2.count(word) > 0) return level; for (int pos = 0; pos 0) { q.insert(word); } } word[pos] = origin; } } swap(q1, q); } return 0; } }; "},"leetcode/longest-consecutive-sequence.html":{"url":"leetcode/longest-consecutive-sequence.html","title":"128.Longest Consecutive Sequence","keywords":"","body":"128. Longest Consecutive Sequence Difficulty: Hard Topics: Array, Union Find Similar Questions: Binary Tree Longest Consecutive Sequence Problem: Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solutions: class Solution { public: int longestConsecutive(vector& nums) { unordered_set numSet (nums.begin(), nums.end()); int ret = 0; for (auto num : nums) { if (numSet.count(num) > 0) { int count = 1; count += countToward(numSet, num - 1, true); count += countToward(numSet, num + 1, false); ret = max(ret, count); } } return ret; } int countToward(unordered_set& numSet, int num, bool backward) { int count = 0; while (true) { auto it = numSet.find(num); if (it == numSet.end()) return count; ++count; numSet.erase(it); if (backward) --num; else ++num; } } }; "},"leetcode/sum-root-to-leaf-numbers.html":{"url":"leetcode/sum-root-to-leaf-numbers.html","title":"129.Sum Root to Leaf Numbers","keywords":"","body":"129. Sum Root to Leaf Numbers Difficulty: Medium Topics: Tree, Depth-first Search Similar Questions: Path Sum Binary Tree Maximum Path Sum Smallest String Starting From Leaf Problem: Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3] 1 / \\ 2 3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1] 4 / \\ 9 0  / \\ 5 1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int sumNumbers(TreeNode* root) { int ret = 0; helper(root, 0, ret); return ret; } void helper(TreeNode* root, int path, int& ret) { if (root == nullptr) { return; } int val = 10 * path + root->val; if (root->left == nullptr && root->right == nullptr) { ret += val; return; } if (root->left) { helper(root->left, val, ret); } if (root->right) { helper(root->right, val, ret); } } }; "},"leetcode/surrounded-regions.html":{"url":"leetcode/surrounded-regions.html","title":"130.Surrounded Regions","keywords":"","body":"130. Surrounded Regions Difficulty: Medium Topics: Depth-first Search, Breadth-first Search, Union Find Similar Questions: Number of Islands Walls and Gates Problem: Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Solutions: class Solution { public: void solve(vector>& board) { int m = board.size(); if (m == 0) return; int n = board[0].size(); if (n == 0) return; vector> visited(m, vector (n, false)); for (int i = 0; i >& board, int row, int col, vector>& visited) { int m = board.size(); int n = board[0].size(); if (row = m || col = n || board[row][col] == 'X' || visited[row][col]) return; visited[row][col] = true; dfs(board, row + 1, col, visited); dfs(board, row - 1, col, visited); dfs(board, row, col - 1, visited); dfs(board, row, col + 1, visited); } }; "},"leetcode/palindrome-partitioning.html":{"url":"leetcode/palindrome-partitioning.html","title":"131.Palindrome Partitioning","keywords":"","body":"131. Palindrome Partitioning Difficulty: Medium Topics: Backtracking Similar Questions: Palindrome Partitioning II Problem: Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: \"aab\" Output: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] Solutions: class Solution { public: vector> partition(string s) { int len = s.length(); vector> ret; vector path; vector> dp(len, vector(len, false)); helper(s, 0, 0, dp, path, ret); return ret; } void helper(string& s, int start, int pos, vector>& dp, vector& path, vector>& ret) { if (pos == s.length()) { if (start == s.length()) { ret.push_back(path); } return; } if (s[pos] == s[start]) { if (start + 1 == pos || start == pos) { dp[start][pos] = true; } else { dp[start][pos] = dp[start + 1][pos - 1]; // it works because another branch has compute dp[start+1][pos-1]. However, it is not a good idea to compute dp inside helper function. } } if (dp[start][pos] == false) { helper(s, start, pos + 1, dp, path, ret); return; } path.push_back(s.substr(start, pos - start + 1)); helper(s, pos + 1, pos + 1, dp, path, ret); path.pop_back(); helper(s, start, pos + 1, dp, path, ret); } }; "},"leetcode/palindrome-partitioning-ii.html":{"url":"leetcode/palindrome-partitioning-ii.html","title":"132.Palindrome Partitioning II","keywords":"","body":"132. Palindrome Partitioning II Difficulty: Hard Topics: Dynamic Programming Similar Questions: Palindrome Partitioning Problem: Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. Solutions: class Solution { public: int minCut(string s) { int len = s.length(); vector> dp(len, vector(len, false)); for (int j = 0; j cache (len, INT_MAX); return helper(s, 0, dp, cache) - 1; } int helper(string& s, int start, vector>& dp, vector& cache) { if (start >= s.length()) return 0; if (cache[start] != INT_MAX) return cache[start]; int ret = INT_MAX; for (int i = start; i "},"leetcode/clone-graph.html":{"url":"leetcode/clone-graph.html","title":"133.Clone Graph","keywords":"","body":"133. Clone Graph Difficulty: Medium Topics: Depth-first Search, Breadth-first Search, Graph Similar Questions: Copy List with Random Pointer Problem: Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.   Example: Input: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1} Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3.   Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. Solutions: /* // Definition for a Node. class Node { public: int val; vector neighbors; Node() {} Node(int _val, vector _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { public: Node* cloneGraph(Node* node) { unordered_map oldToNew; return helper(node, oldToNew); } Node* helper(Node* node, unordered_map& oldToNew) { if (node == NULL) return NULL; if (oldToNew.count(node) > 0) return oldToNew[node]; Node* newNode = new Node(node->val, {}); oldToNew[node] = newNode; for (auto& neighbor : node->neighbors) { newNode->neighbors.push_back(helper(neighbor, oldToNew)); } return newNode; } }; "},"leetcode/gas-station.html":{"url":"leetcode/gas-station.html","title":"134.Gas Station","keywords":"","body":"134. Gas Station Difficulty: Medium Topics: Greedy Similar Questions: Problem: There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: Input: gas = [1,2,3,4,5] cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2,3,4] cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Solutions: class Solution { public: int canCompleteCircuit(vector& gas, vector& cost) { int n = gas.size(); int total = 0; int start = 0; int acc = 0; for (int i = 0; i "},"leetcode/candy.html":{"url":"leetcode/candy.html","title":"135.Candy","keywords":"","body":"135. Candy Difficulty: Hard Topics: Greedy Similar Questions: Problem: There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. Solutions: class Solution { public: int candy(vector& ratings) { // pay attention to the condition that two adjecent ratings are equal int n = ratings.size(); vector candyCount (n, 0); vector> ratingWithIndex; for (int i = 0; i = 0 && ratings[index] > ratings[index - 1]) { candyCount[index] = max(candyCount[index], candyCount[index - 1] + 1); } if (index + 1 ratings[index + 1]) { candyCount[index] = max(candyCount[index], candyCount[index + 1] + 1); } sum += candyCount[index]; } return sum; } }; "},"leetcode/single-number.html":{"url":"leetcode/single-number.html","title":"136.Single Number","keywords":"","body":"136. Single Number Difficulty: Easy Topics: Hash Table, Bit Manipulation Similar Questions: Single Number II Single Number III Missing Number Find the Duplicate Number Find the Difference Problem: Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 Solutions: class Solution { public: int singleNumber(vector& nums) { int ret = 0; for (auto num : nums) { ret ^= num; } return ret; } }; "},"leetcode/single-number-ii.html":{"url":"leetcode/single-number-ii.html","title":"137.Single Number II","keywords":"","body":"137. Single Number II Difficulty: Medium Topics: Bit Manipulation Similar Questions: Single Number Single Number III Problem: Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3 Example 2: Input: [0,1,0,1,0,1,99] Output: 99 Solutions: class Solution { public: int singleNumber(vector& nums) { int ones = 0; int tens = 0; for (auto num : nums) { ones = ones ^ num; int carry = (~ones) & num; tens = tens ^ carry; int mask = ones & tens; ones = ones & (~mask); tens = tens & (~mask); } return ones; } }; "},"leetcode/copy-list-with-random-pointer.html":{"url":"leetcode/copy-list-with-random-pointer.html","title":"138.Copy List with Random Pointer","keywords":"","body":"138. Copy List with Random Pointer Difficulty: Medium Topics: Hash Table, Linked List Similar Questions: Clone Graph Problem: A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.   Example 1: Input: {\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1} Explanation: Node 1's value is 1, both of its next and random pointer points to Node 2. Node 2's value is 2, its next pointer points to null and its random pointer points to itself.   Note: You must return the copy of the given head as a reference to the cloned list. Solutions: /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node() {} Node(int _val, Node* _next, Node* _random) { val = _val; next = _next; random = _random; } }; */ class Solution { public: Node* copyRandomList(Node* head) { copyNodes(head); copyRandomPointers(head); return partition(head); } void copyNodes(Node* head) { while (head) { Node* nodeCopy = new Node(head->val, head->next, nullptr); head->next = nodeCopy; head = nodeCopy->next; } } void copyRandomPointers(Node* head) { while (head) { head->next->random = head->random == nullptr ? nullptr : head->random->next; // pay attention to null random pointer head = head->next->next; } } Node* partition(Node* head) { Node* dummy = new Node(0, nullptr, nullptr); Node* tail = dummy; while (head) { tail->next = head->next; tail = tail->next; head->next = head->next->next; head = head->next; } return dummy->next; } }; "},"leetcode/word-break.html":{"url":"leetcode/word-break.html","title":"139.Word Break","keywords":"","body":"139. Word Break Difficulty: Medium Topics: Dynamic Programming Similar Questions: Word Break II Problem: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".   Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false Solutions: class Solution { public: struct TrieNode{ bool stop; TrieNode* next[26]; TrieNode(bool stop = false) { this->stop = stop; for (int i = 0; i cur = cur; } void rewind() { cur = root; } bool next(char c) { if (cur == nullptr || cur->next[c - 'a'] == nullptr) { cur = nullptr; return false; } cur = cur->next[c - 'a']; return true; } bool isWord() { return cur->stop; } void input(string s) { cur = root; for (auto c : s) { if (cur->next[c - 'a'] == nullptr) { cur->next[c - 'a'] = new TrieNode(); } cur = cur->next[c - 'a']; } cur->stop = true; cur = root; } private: TrieNode* root; TrieNode* cur; }; bool wordBreak(string s, vector& wordDict) { Trie trie; for (auto word : wordDict) { trie.input(word); } unordered_map cache; return helper(s, 0, trie, cache); } bool helper(const string& s, int pos, Trie& trie, unordered_map& cache) { if (pos == s.length()) return true; if (cache.count(pos) > 0) return cache[pos]; for (int i = pos; i "},"leetcode/word-break-ii.html":{"url":"leetcode/word-break-ii.html","title":"140.Word Break II","keywords":"","body":"140. Word Break II Difficulty: Hard Topics: Dynamic Programming, Backtracking Similar Questions: Word Break Concatenated Words Problem: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"catsanddog\" wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output: [   \"cats and dog\",   \"cat sand dog\" ] Example 2: Input: s = \"pineapplepenapple\" wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] Output: [   \"pine apple pen apple\",   \"pineapple pen apple\",   \"pine applepen apple\" ] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\" wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: [] Solutions: class Solution { public: struct TrieNode{ bool stop; TrieNode* next[26]; TrieNode(bool stop = false) { this->stop = stop; for (int i = 0; i cur = cur; } void rewind() { cur = root; } bool next(char c) { if (cur == nullptr || cur->next[c - 'a'] == nullptr) { cur = nullptr; return false; } cur = cur->next[c - 'a']; return true; } bool isWord() { return cur->stop; } void input(string s) { cur = root; for (auto c : s) { if (cur->next[c - 'a'] == nullptr) { cur->next[c - 'a'] = new TrieNode(); } cur = cur->next[c - 'a']; } cur->stop = true; cur = root; } private: TrieNode* root; TrieNode* cur; }; vector wordBreak(string s, vector& wordDict) { Trie trie; for (auto word : wordDict) { trie.input(word); } unordered_map>> cache; auto wordLists = helper(s, 0, trie, cache); vector ret; for (auto& wordList : wordLists) { ret.push_back(join(wordList)); } return ret; } string join(const vector& path) { string s; if (path.size() == 0) return s; s = path[0]; for (int i = 1; i > helper(const string& s, int pos, Trie& trie, unordered_map>>& cache) { vector> ret; if (cache.count(pos) > 0) { return cache[pos]; } for (int j = pos; j "},"leetcode/linked-list-cycle.html":{"url":"leetcode/linked-list-cycle.html","title":"141.Linked List Cycle","keywords":"","body":"141. Linked List Cycle Difficulty: Easy Topics: Linked List, Two Pointers Similar Questions: Linked List Cycle II Happy Number Problem: Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.   Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.   Follow up: Can you solve it using O(1) (i.e. constant) memory? Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast && fast->next) { fast = fast->next->next; slow = slow->next; if (fast == slow) return true; } return false; } }; "},"leetcode/linked-list-cycle-ii.html":{"url":"leetcode/linked-list-cycle-ii.html","title":"142.Linked List Cycle II","keywords":"","body":"142. Linked List Cycle II Difficulty: Medium Topics: Linked List, Two Pointers Similar Questions: Linked List Cycle Find the Duplicate Number Problem: Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list.   Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list.   Follow-up: Can you solve it without using extra space? Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast && fast->next) { fast = fast->next->next; slow = slow->next; if (slow == fast) break; } if (fast != slow || head == NULL || head->next == NULL) return NULL; ListNode* another = head; while (another != slow) { another = another->next; slow = slow->next; } return another; } }; "},"leetcode/binary-tree-preorder-traversal.html":{"url":"leetcode/binary-tree-preorder-traversal.html","title":"144.Binary Tree Preorder Traversal","keywords":"","body":"144. Binary Tree Preorder Traversal Difficulty: Medium Topics: Stack, Tree Similar Questions: Binary Tree Inorder Traversal Verify Preorder Sequence in Binary Search Tree N-ary Tree Preorder Traversal Problem: Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector preorderTraversal(TreeNode* root) { vector ret; TreeNode* cur = root; while (cur) { TreeNode* pre = cur->left; if (pre == nullptr) { ret.push_back(cur->val); // visit cur = cur->right; continue; } while (pre->right != nullptr && pre->right != cur) { pre = pre->right; } if (pre->right == nullptr) { pre->right = cur; ret.push_back(cur->val); // visit cur = cur->left; } else { pre->right = nullptr; cur = cur->right; } } return ret; } }; "},"leetcode/binary-tree-postorder-traversal.html":{"url":"leetcode/binary-tree-postorder-traversal.html","title":"145.Binary Tree Postorder Traversal","keywords":"","body":"145. Binary Tree Postorder Traversal Difficulty: Hard Topics: Stack, Tree Similar Questions: Binary Tree Inorder Traversal N-ary Tree Postorder Traversal Problem: Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reverse(TreeNode* head) { TreeNode* dummy = new TreeNode(0); TreeNode* next; while (head) { next = head->right; head->right = dummy->right; dummy->right = head; head = next; } return dummy->right; } void visit(TreeNode* from, TreeNode* to, vector& ret) { TreeNode* newHead = reverse(from); TreeNode* cur = newHead; while (cur != nullptr) { ret.push_back(cur->val); cur = cur->right; } reverse(newHead); } vector postorderTraversal(TreeNode* root) { vector ret; TreeNode* dummy = new TreeNode(0); dummy->left = root; TreeNode* cur = dummy; while (cur) { if (cur->left == nullptr) { cur = cur->right; } else { TreeNode* pre = cur->left; while (pre->right != nullptr && pre->right != cur) { pre = pre->right; } if (pre->right == nullptr) { pre->right = cur; cur = cur->left; } else { pre->right = nullptr; visit(cur->left, pre, ret); cur = cur->right; } } } return ret; } }; "},"leetcode/insertion-sort-list.html":{"url":"leetcode/insertion-sort-list.html","title":"147.Insertion Sort List","keywords":"","body":"147. Insertion Sort List Difficulty: Medium Topics: Linked List, Sort Similar Questions: Sort List Insert into a Cyclic Sorted List Problem: Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list   Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: Input: 4->2->1->3 Output: 1->2->3->4 Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* insertionSortList(ListNode* head) { ListNode* dummy = new ListNode(0); while (head) { ListNode* next = head->next; insert(dummy, head); head = next; } return dummy->next; } void insert(ListNode* head, ListNode* cur) { while (head->next && head->next->val val) head = head->next; if (head->next == nullptr) { head->next = cur; cur->next = nullptr; } else { cur->next = head->next; head->next = cur; } } }; "},"leetcode/sort-list.html":{"url":"leetcode/sort-list.html","title":"148.Sort List","keywords":"","body":"148. Sort List Difficulty: Medium Topics: Linked List, Sort Similar Questions: Merge Two Sorted Lists Sort Colors Insertion Sort List Problem: Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4 Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { if (head == nullptr) return nullptr; if (head->next == nullptr) return head; ListNode* slow = head; ListNode* fast = head; while (fast->next != nullptr && fast->next->next != nullptr) { slow = slow->next; fast = fast->next->next; } ListNode* head2 = slow->next; slow->next = nullptr; ListNode* leftHead = sortList(head); ListNode* rightHead = sortList(head2); ListNode* dummy = new ListNode(0); ListNode* tail = dummy; while (leftHead != nullptr && rightHead != nullptr) { if (leftHead->val val) { tail->next = leftHead; tail = leftHead; leftHead = leftHead->next; } else { tail->next = rightHead; tail = rightHead; rightHead = rightHead->next; } } if (leftHead == nullptr) { tail->next = rightHead; } else { tail->next = leftHead; } return dummy->next; } }; "},"leetcode/max-points-on-a-line.html":{"url":"leetcode/max-points-on-a-line.html","title":"149.Max Points on a Line","keywords":"","body":"149. Max Points on a Line Difficulty: Hard Topics: Hash Table, Math Similar Questions: Line Reflection Problem: Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3 4 Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | | o |     o   o |      o |  o   o +-------------------> 0  1  2  3  4  5  6 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solutions: class Solution { public: int maxPoints(vector>& points) { int ret = 0; for (int i = 0; i , int> lines; int verticleCount = 0; // dedicated int horizonCount = 0; // dedicated int selfCount = 1; for (int j = i + 1; j simplify(int a, int b) { if (a "},"leetcode/evaluate-reverse-polish-notation.html":{"url":"leetcode/evaluate-reverse-polish-notation.html","title":"150.Evaluate Reverse Polish Notation","keywords":"","body":"150. Evaluate Reverse Polish Notation Difficulty: Medium Topics: Stack Similar Questions: Basic Calculator Expression Add Operators Problem: Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Solutions: class Solution { public: int evalRPN(vector& tokens) { stack nums; for (auto& token : tokens) { if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") { int op1 = nums.top(); nums.pop(); int op2 = nums.top(); nums.pop(); int ret; switch(token[0]) { case '+': ret = op1 + op2; break; case '-': ret = op2 - op1; // take care of the order break; case '*': ret = op1 * op2; break; case '/': ret = op2 / op1; // take care of the order break; } nums.push(ret); } else { nums.push(stoi(token)); } } return nums.top(); } }; "},"leetcode/reverse-words-in-a-string.html":{"url":"leetcode/reverse-words-in-a-string.html","title":"151.Reverse Words in a String","keywords":"","body":"151. Reverse Words in a String Difficulty: Medium Topics: String Similar Questions: Reverse Words in a String II Problem: Given an input string, reverse the string word by word.   Example 1: Input: \"the sky is blue\" Output: \"blue is sky the\" Example 2: Input: \"  hello world!  \" Output: \"world! hello\" Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: Input: \"a good   example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.   Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.   Follow up: For C programmers, try to solve it in-place in O(1) extra space. Solutions: class Solution { public: string reverseWords(string s) { string ret; stringstream ss(s); string word; if (ss >> word) { ret.append(word); } while (ss >> word) { ret.push_back(' '); ret.append(word); } if (ret.length() == 0) return ret; // left and right are both facing right int left = 0; int right = 0; while (right "},"leetcode/find-minimum-in-rotated-sorted-array.html":{"url":"leetcode/find-minimum-in-rotated-sorted-array.html","title":"153.Find Minimum in Rotated Sorted Array","keywords":"","body":"153. Find Minimum in Rotated Sorted Array Difficulty: Medium Topics: Array, Binary Search Similar Questions: Search in Rotated Sorted Array Find Minimum in Rotated Sorted Array II Problem: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2] Output: 1 Example 2: Input: [4,5,6,7,0,1,2] Output: 0 Solutions: class Solution { public: typedef bool (*check)(vector&, int index); static bool checkMin(vector& nums, int index) { return nums[index] & nums) { if (nums.size() == 0) return -1; if (nums.size() == 1) return nums[0]; if (nums[0] "},"leetcode/min-stack.html":{"url":"leetcode/min-stack.html","title":"155.Min Stack","keywords":"","body":"155. Min Stack Difficulty: Easy Topics: Stack, Design Similar Questions: Sliding Window Maximum Max Stack Problem: Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack.   Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> Returns -3. minStack.pop(); minStack.top(); --> Returns 0. minStack.getMin(); --> Returns -2.   Solutions: class MinStack { public: /** initialize your data structure here. */ MinStack() { } void push(int x) { if (mins.empty() || mins.top() >= x) { mins.push(x); } stk.push(x); } void pop() { int num = stk.top(); stk.pop(); if (!mins.empty() && num == mins.top()) { mins.pop(); } } int top() { return stk.top(); } int getMin() { if (mins.empty()) { return -1; } return mins.top(); } private: stack stk; stack mins; }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(x); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */ "},"leetcode/binary-tree-upside-down.html":{"url":"leetcode/binary-tree-upside-down.html","title":"156.Binary Tree Upside Down","keywords":"","body":"156. Binary Tree Upside Down Difficulty: Medium Topics: Tree Similar Questions: Reverse Linked List Problem: Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. Example: Input: [1,2,3,4,5] 1 / \\ 2 3 / \\ 4 5 Output: return the root of the binary tree [4,5,2,#,#,3,1] 4 / \\ 5 2 / \\ 3 1 Clarification: Confused what [4,5,2,#,#,3,1] means? Read more below on how binary tree is serialized on OJ. The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as [1,2,3,#,#,4,#,#,5]. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* upsideDownBinaryTree(TreeNode* root) { if (root == nullptr) return nullptr; if (root->left == nullptr && root->right == nullptr) return root; TreeNode* leftNode = root->left; TreeNode* rightNode = root->right; TreeNode* leftSubUpsideDown = upsideDownBinaryTree(leftNode); TreeNode* rightSubUpsideDown = upsideDownBinaryTree(rightNode); leftNode->left = rightSubUpsideDown; leftNode->right = root; root->left = nullptr; // set nullptr root->right = nullptr; // set nullptr return leftSubUpsideDown; } }; "},"leetcode/read-n-characters-given-read4.html":{"url":"leetcode/read-n-characters-given-read4.html","title":"157.Read N Characters Given Read4","keywords":"","body":"157. Read N Characters Given Read4 Difficulty: Easy Topics: String Similar Questions: Read N Characters Given Read4 II - Call multiple times Problem: Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters.   Method read4: The API read4 reads 4 consecutive characters from the file, then writes those characters into the buffer array buf. The return value is the number of actual characters read. Note that read4() has its own file pointer, much like FILE *fp in C. Definition of read4: Parameter: char[] buf Returns: int Note: buf[] is destination not source, the results from read4 will be copied to buf[] Below is a high level example of how read4 works: File file(\"abcdefghijk\"); // File is \"abcdefghijk\", initially file pointer (fp) points to 'a' char[] buf = new char[4]; // Create buffer with enough space to store characters read4(buf); // read4 returns 4. Now buf = \"abcd\", fp points to 'e' read4(buf); // read4 returns 4. Now buf = \"efgh\", fp points to 'i' read4(buf); // read4 returns 3. Now buf = \"ijk\", fp points to end of file   Method read: By using the read4 method, implement the method read that reads n characters from the file and store it in the buffer array buf. Consider that you cannot manipulate the file directly. The return value is the number of actual characters read. Definition of read: Parameters: char[] buf, int n Returns: int Note: buf[] is destination not source, you will need to write the results to buf[]   Example 1: Input: file = \"abc\", n = 4 Output: 3 Explanation: After calling your read method, buf should contain \"abc\". We read a total of 3 characters from the file, so return 3. Note that \"abc\" is the file's content, not buf. buf is the destination buffer that you will have to write the results to. Example 2: Input: file = \"abcde\", n = 5 Output: 5 Explanation: After calling your read method, buf should contain \"abcde\". We read a total of 5 characters from the file, so return 5. Example 3: Input: file = \"abcdABCD1234\", n = 12 Output: 12 Explanation: After calling your read method, buf should contain \"abcdABCD1234\". We read a total of 12 characters from the file, so return 12. Example 4: Input: file = \"leetcode\", n = 5 Output: 5 Explanation: After calling your read method, buf should contain \"leetc\". We read a total of 5 characters from the file, so return 5.   Note: Consider that you cannot manipulate the file directly, the file is only accesible for read4 but not for read. The read function will only be called once for each test case. You may assume the destination buffer array, buf, is guaranteed to have enough space for storing n characters. Solutions: // Forward declaration of the read4 API. int read4(char *buf); class Solution { public: /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ int read(char *buf, int n) { int count = 0; char readBuf[4]; while (count + 4 = n) { memcpy(buf + count, readBuf, n - count); return n; } else { memcpy(buf + count, readBuf, readCount); return count + readCount; } } }; "},"leetcode/read-n-characters-given-read4-ii-call-multiple-times.html":{"url":"leetcode/read-n-characters-given-read4-ii-call-multiple-times.html","title":"158.Read N Characters Given Read4 II - Call multiple times","keywords":"","body":"158. Read N Characters Given Read4 II - Call multiple times Difficulty: Hard Topics: String Similar Questions: Read N Characters Given Read4 Problem: Given a file and assume that you can only read the file using a given method read4, implement a method read to read n characters. Your method read may be called multiple times.   Method read4: The API read4 reads 4 consecutive characters from the file, then writes those characters into the buffer array buf. The return value is the number of actual characters read. Note that read4() has its own file pointer, much like FILE *fp in C. Definition of read4: Parameter: char[] buf Returns: int Note: buf[] is destination not source, the results from read4 will be copied to buf[] Below is a high level example of how read4 works: File file(\"abcdefghijk\"); // File is \"abcdefghijk\", initially file pointer (fp) points to 'a' char[] buf = new char[4]; // Create buffer with enough space to store characters read4(buf); // read4 returns 4. Now buf = \"abcd\", fp points to 'e' read4(buf); // read4 returns 4. Now buf = \"efgh\", fp points to 'i' read4(buf); // read4 returns 3. Now buf = \"ijk\", fp points to end of file   Method read: By using the read4 method, implement the method read that reads n characters from the file and store it in the buffer array buf. Consider that you cannot manipulate the file directly. The return value is the number of actual characters read. Definition of read: Parameters: char[] buf, int n Returns: int Note: buf[] is destination not source, you will need to write the results to buf[]   Example 1: File file(\"abc\"); Solution sol; // Assume buf is allocated and guaranteed to have enough space for storing all characters from the file. sol.read(buf, 1); // After calling your read method, buf should contain \"a\". We read a total of 1 character from the file, so return 1. sol.read(buf, 2); // Now buf should contain \"bc\". We read a total of 2 characters from the file, so return 2. sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0. Example 2: File file(\"abc\"); Solution sol; sol.read(buf, 4); // After calling your read method, buf should contain \"abc\". We read a total of 3 characters from the file, so return 3. sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.   Note: Consider that you cannot manipulate the file directly, the file is only accesible for read4 but not for read. The read function may be called multiple times. Please remember to RESET your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see here for more details. You may assume the destination buffer array, buf, is guaranteed to have enough space for storing n characters. It is guaranteed that in a given test case the same buffer buf is called by read. Solutions: // Forward declaration of the read4 API. int read4(char *buf); class Solution { public: /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ int read(char *buf, int n) { int count = 0; while (count "},"leetcode/longest-substring-with-at-most-two-distinct-characters.html":{"url":"leetcode/longest-substring-with-at-most-two-distinct-characters.html","title":"159.Longest Substring with At Most Two Distinct Characters","keywords":"","body":"159. Longest Substring with At Most Two Distinct Characters Difficulty: Hard Topics: Hash Table, Two Pointers, String, Sliding Window Similar Questions: Longest Substring Without Repeating Characters Sliding Window Maximum Longest Substring with At Most K Distinct Characters Subarrays with K Different Integers Problem: Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: t is \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: t is \"aabbb\" which its length is 5. Solutions: class Solution { public: int lengthOfLongestSubstringTwoDistinct(string s) { unordered_map charCount; int left = 0; int maxLen = 0; for (int right = 0; right 2) { if(--charCount[s[left]] == 0) charCount.erase(s[left]); ++left; } } } return maxLen; } }; "},"leetcode/intersection-of-two-linked-lists.html":{"url":"leetcode/intersection-of-two-linked-lists.html","title":"160.Intersection of Two Linked Lists","keywords":"","body":"160. Intersection of Two Linked Lists Difficulty: Easy Topics: Linked List Similar Questions: Minimum Index Sum of Two Lists Problem: Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1.   Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.   Example 2: Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.   Example 3: Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null.   Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == NULL || headB == NULL) return NULL; // rememeber to check NULL at first; bool rewindA = false; bool rewindB = false; ListNode* curA = headA; ListNode* curB = headB; do { if (curA == curB) return curA; if (curA->next) { curA = curA->next; } else if (!rewindA) { curA = headB; rewindA = true; } else { return NULL; } if (curB->next) { curB = curB->next; } else if (!rewindB) { curB = headA; rewindB = true; } else { return NULL; } } while (true); } }; "},"leetcode/one-edit-distance.html":{"url":"leetcode/one-edit-distance.html","title":"161.One Edit Distance","keywords":"","body":"161. One Edit Distance Difficulty: Medium Topics: String Similar Questions: Edit Distance Problem: Given two strings s and t, determine if they are both one edit distance apart. Note:  There are 3 possiblities to satisify one edit distance apart: Insert a character into s to get t Delete a character from s to get t Replace a character of s to get t Example 1: Input: s = \"ab\", t = \"acb\" Output: true Explanation: We can insert 'c' into s to get t. Example 2: Input: s = \"cab\", t = \"ad\" Output: false Explanation: We cannot get t from s by only one step. Example 3: Input: s = \"1203\", t = \"1213\" Output: true Explanation: We can replace '0' with '1' to get t. Solutions: class Solution { public: bool isOneEditDistance(string s, string t) { if (s.length() == t.length()) { return isOneReplace(s, t); } else { if (s.length() - t.length() == 1) { return isOneDelete(s, t); } else if (t.length() - s.length() == 1) { return isOneDelete(t, s); } else { return false; } } } bool isOneReplace(string& s, string& t) { int diff = 0; for (int i = 0; i 1) return false; } } return diff == 1; } bool isOneDelete(string& s, string& t) { int i = 0; while (i "},"leetcode/find-peak-element.html":{"url":"leetcode/find-peak-element.html","title":"162.Find Peak Element","keywords":"","body":"162. Find Peak Element Difficulty: Medium Topics: Array, Binary Search Similar Questions: Peak Index in a Mountain Array Problem: A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2,   or index number 5 where the peak element is 6. Note: Your solution should be in logarithmic complexity. Solutions: class Solution { public: int findPeakElement(vector& nums) { // this problem does not eliminate the scenario [1] int left = 0; int right = nums.size() - 1; while (left + 1 nums[mid-1] && nums[mid] > nums[mid + 1]) return mid; if (nums[mid] left + 1 && nums[left + 1] left + 1 && left -1 >= 0 && nums[left] > nums[left - 1] && nums[left] > nums[left + 1]) return left; else return right; } } }; "},"leetcode/missing-ranges.html":{"url":"leetcode/missing-ranges.html","title":"163.Missing Ranges","keywords":"","body":"163. Missing Ranges Difficulty: Medium Topics: Array Similar Questions: Summary Ranges Problem: Given a sorted integer array nums, where the range of elements are in the inclusive range [lower, upper], return its missing ranges. Example: Input: nums = [0, 1, 3, 50, 75], lower = 0 and upper = 99, Output: [\"2\", \"4->49\", \"51->74\", \"76->99\"] Solutions: class Solution { public: vector findMissingRanges(vector& nums, int lower, int upper) { vector ret; int expected = lower; for (auto num : nums) { if (num \" + to_string(upper); } } }; "},"leetcode/maximum-gap.html":{"url":"leetcode/maximum-gap.html","title":"164.Maximum Gap","keywords":"","body":"164. Maximum Gap Difficulty: Hard Topics: Sort Similar Questions: Problem: Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either   (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. Solutions: class Solution { public: int maximumGap(vector& nums) { if (nums.size() bucketMax (n, INT_MIN); vector bucketMin (n, INT_MAX); for (auto num : nums) { int index = (num - minElement) / bucketSize; bucketMax[index] = max(bucketMax[index], num); bucketMin[index] = min(bucketMin[index], num); } int max_gap = 0; int prev_max = bucketMax[0]; for (int i = 1; i "},"leetcode/compare-version-numbers.html":{"url":"leetcode/compare-version-numbers.html","title":"165.Compare Version Numbers","keywords":"","body":"165. Compare Version Numbers Difficulty: Medium Topics: String Similar Questions: Problem: Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.   Example 1: Input: version1 = \"0.1\", version2 = \"1.1\" Output: -1 Example 2: Input: version1 = \"1.0.1\", version2 = \"1\" Output: 1 Example 3: Input: version1 = \"7.5.2.4\", version2 = \"7.5.3\" Output: -1 Example 4: Input: version1 = \"1.01\", version2 = \"1.001\" Output: 0 Explanation: Ignoring leading zeroes, both “01” and “001\" represent the same number “1” Example 5: Input: version1 = \"1.0\", version2 = \"1.0.0\" Output: 0 Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to \"0\"   Note: Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. Version strings do not start or end with dots, and they will not be two consecutive dots. Solutions: class Solution { public: int compareVersion(string version1, string version2) { int cur1 = 0; int cur2 = 0; int len1 = version1.length(); int len2 = version2.length(); while (cur1 value2) { return 1; } } return 0; } }; "},"leetcode/two-sum-ii-input-array-is-sorted.html":{"url":"leetcode/two-sum-ii-input-array-is-sorted.html","title":"167.Two Sum II - Input array is sorted","keywords":"","body":"167. Two Sum II - Input array is sorted Difficulty: Easy Topics: Array, Two Pointers, Binary Search Similar Questions: Two Sum Two Sum IV - Input is a BST Two Sum Less Than K Problem: Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. Solutions: class Solution { public: vector twoSum(vector& numbers, int target) { int left = 0; int right = numbers.size() - 1; while (left "},"leetcode/excel-sheet-column-title.html":{"url":"leetcode/excel-sheet-column-title.html","title":"168.Excel Sheet Column Title","keywords":"","body":"168. Excel Sheet Column Title Difficulty: Easy Topics: Math Similar Questions: Excel Sheet Column Number Problem: Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB ... Example 1: Input: 1 Output: \"A\" Example 2: Input: 28 Output: \"AB\" Example 3: Input: 701 Output: \"ZY\" Solutions: class Solution { public: string convertToTitle(int n) { string ret; while (n > 0) { ret.push_back( (n - 1) % 26 + 'A'); n = (n - 1)/ 26; } reverse(ret.begin(), ret.end()); return ret; } }; "},"leetcode/majority-element.html":{"url":"leetcode/majority-element.html","title":"169.Majority Element","keywords":"","body":"169. Majority Element Difficulty: Easy Topics: Array, Divide and Conquer, Bit Manipulation Similar Questions: Majority Element II Check If a Number Is Majority Element in a Sorted Array Problem: Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2 Solutions: class Solution { public: int majorityElement(vector& nums) { if (nums.size() == 0) return -1; int count = 0; int majority = nums[0]; for (auto num : nums) { if (num == majority) { ++count; } else { if (--count == 0) { majority = num; count = 1; } } } return majority; } }; "},"leetcode/two-sum-iii-data-structure-design.html":{"url":"leetcode/two-sum-iii-data-structure-design.html","title":"170.Two Sum III - Data structure design","keywords":"","body":"170. Two Sum III - Data structure design Difficulty: Easy Topics: Hash Table, Design Similar Questions: Two Sum Unique Word Abbreviation Two Sum IV - Input is a BST Problem: Design and implement a TwoSum class. It should support the following operations: add and find. add - Add the number to an internal data structure. find - Find if there exists any pair of numbers which sum is equal to the value. Example 1: add(1); add(3); add(5); find(4) -> true find(7) -> false Example 2: add(3); add(1); add(2); find(3) -> true find(6) -> false Solutions: class TwoSum { public: /** Initialize your data structure here. */ TwoSum() { } /** Add the number to an internal data structure.. */ void add(int number) { ++count[number]; } /** Find if there exists any pair of numbers which sum is equal to the value. */ bool find(int value) { for (auto valueCount : count) { int target = value - valueCount.first; auto it = count.find(target); if (it != count.end() && (target != valueCount.first || it->second > 1)) return true; } return false; } private: unordered_map count; }; /** * Your TwoSum object will be instantiated and called as such: * TwoSum* obj = new TwoSum(); * obj->add(number); * bool param_2 = obj->find(value); */ "},"leetcode/excel-sheet-column-number.html":{"url":"leetcode/excel-sheet-column-number.html","title":"171.Excel Sheet Column Number","keywords":"","body":"171. Excel Sheet Column Number Difficulty: Easy Topics: Math Similar Questions: Excel Sheet Column Title Problem: Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... Example 1: Input: \"A\" Output: 1 Example 2: Input: \"AB\" Output: 28 Example 3: Input: \"ZY\" Output: 701 Solutions: class Solution { public: int titleToNumber(string s) { int ret = 0; for (int i = 0; i "},"leetcode/factorial-trailing-zeroes.html":{"url":"leetcode/factorial-trailing-zeroes.html","title":"172.Factorial Trailing Zeroes","keywords":"","body":"172. Factorial Trailing Zeroes Difficulty: Easy Topics: Math Similar Questions: Number of Digit One Preimage Size of Factorial Zeroes Function Problem: Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity. Solutions: class Solution { public: int trailingZeroes(int n) { int count = 0; int divisor = 5; while (n >= divisor) { count += n/divisor; n /= 5; // be careful about overflow! } return count; } }; "},"leetcode/binary-search-tree-iterator.html":{"url":"leetcode/binary-search-tree-iterator.html","title":"173.Binary Search Tree Iterator","keywords":"","body":"173. Binary Search Tree Iterator Difficulty: Medium Topics: Stack, Tree, Design Similar Questions: Binary Tree Inorder Traversal Flatten 2D Vector Zigzag Iterator Peeking Iterator Inorder Successor in BST Problem: Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.   Example: BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.hasNext(); // return true iterator.next(); // return 20 iterator.hasNext(); // return false   Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class BSTIterator { public: BSTIterator(TreeNode* root) { while (root) { stk.push(root); root = root->left; } } /** @return the next smallest number */ int next() { TreeNode* node = stk.top(); stk.pop(); int ret = node->val; node = node->right; while (node) { stk.push(node); node = node->left; } return ret; } /** @return whether we have a next smallest number */ bool hasNext() { return !stk.empty(); } private: stack stk; }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ "},"leetcode/combine-two-tables.html":{"url":"leetcode/combine-two-tables.html","title":"175.Combine Two Tables","keywords":"","body":"175. Combine Two Tables Difficulty: Easy Topics: Similar Questions: Employee Bonus Problem: Table: Person +-------------+---------+ | Column Name | Type | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId is the primary key column for this table. Table: Address +-------------+---------+ | Column Name | Type | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId is the primary key column for this table.   Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State Solutions: # Write your MySQL query statement below SELECT Person.FirstName, Person.LastName, Address.City, Address.State FROM Person LEFT JOIN Address on Person.PersonId = Address.PersonId "},"leetcode/largest-number.html":{"url":"leetcode/largest-number.html","title":"179.Largest Number","keywords":"","body":"179. Largest Number Difficulty: Medium Topics: Sort Similar Questions: Problem: Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: \"210\" Example 2: Input: [3,30,34,5,9] Output: \"9534330\" Note: The result may be very large, so you need to return a string instead of an integer. Solutions: class Solution { public: struct comparator { bool operator()(const string& a, const string& b) { return a + b > b + a; // not necessary to have stol; } }; string largestNumber(vector& nums) { vector numStr; bool allZeros = true; for (auto num : nums) { if (num != 0) allZeros = false; numStr.push_back(to_string(num)); } if (allZeros == true) return \"0\"; sort(numStr.begin(), numStr.end(), comparator()); string ret; for (auto& str : numStr) { ret.append(str); } return ret; } }; "},"leetcode/reverse-words-in-a-string-ii.html":{"url":"leetcode/reverse-words-in-a-string-ii.html","title":"186.Reverse Words in a String II","keywords":"","body":"186. Reverse Words in a String II Difficulty: Medium Topics: String Similar Questions: Reverse Words in a String Rotate Array Problem: Given an input string , reverse the string word by word.  Example: Input: [\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"] Output: [\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"] Note:  A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces. The words are always separated by a single space. Follow up: Could you do it in-place without allocating extra space? Solutions: class Solution { public: void reverseWords(vector& s) { int start = 0; int end = 0; while (start & s, int start, int end) { while (start "},"leetcode/repeated-dna-sequences.html":{"url":"leetcode/repeated-dna-sequences.html","title":"187.Repeated DNA Sequences","keywords":"","body":"187. Repeated DNA Sequences Difficulty: Medium Topics: Hash Table, Bit Manipulation Similar Questions: Problem: All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" Output: [\"AAAAACCCCC\", \"CCCCCAAAAA\"] Solutions: class Solution { public: vector findRepeatedDnaSequences(string s) { if (s.length() merCount; vector ret; for (int i = 9; i "},"leetcode/best-time-to-buy-and-sell-stock-iv.html":{"url":"leetcode/best-time-to-buy-and-sell-stock-iv.html","title":"188.Best Time to Buy and Sell Stock IV","keywords":"","body":"188. Best Time to Buy and Sell Stock IV Difficulty: Hard Topics: Dynamic Programming Similar Questions: Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock II Best Time to Buy and Sell Stock III Problem: Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.   Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Solutions: class Solution { public: int maxProfit(int k, vector& prices) { int n = prices.size(); if (k == 0 || n == 0) return 0; k = min(k, n/2); vector> hold (n , vector (2, 0)); vector> empty(n , vector (2, 0)); for (int i = 0; i "},"leetcode/rotate-array.html":{"url":"leetcode/rotate-array.html","title":"189.Rotate Array","keywords":"","body":"189. Rotate Array Difficulty: Easy Topics: Array Similar Questions: Rotate List Reverse Words in a String II Problem: Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Solutions: class Solution { public: void rotate(vector& nums, int k) { k = k % nums.size(); swap(nums, nums.size() - k, nums.size() -1); swap(nums, 0, nums.size() - k - 1); swap(nums, 0, nums.size() - 1); // it is nums.size() -1 return; } void swap(vector& nums, int left, int right) { while (left "},"leetcode/reverse-bits.html":{"url":"leetcode/reverse-bits.html","title":"190.Reverse Bits","keywords":"","body":"190. Reverse Bits Difficulty: Easy Topics: Bit Manipulation Similar Questions: Reverse Integer Number of 1 Bits Problem: Reverse bits of a given 32 bits unsigned integer.   Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.   Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.   Follow up: If this function is called many times, how would you optimize it? Solutions: class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t result = 0; const uint32_t product = 1 "},"leetcode/number-of-1-bits.html":{"url":"leetcode/number-of-1-bits.html","title":"191.Number of 1 Bits","keywords":"","body":"191. Number of 1 Bits Difficulty: Easy Topics: Bit Manipulation Similar Questions: Reverse Bits Power of Two Counting Bits Binary Watch Hamming Distance Binary Number with Alternating Bits Prime Number of Set Bits in Binary Representation Problem: Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).   Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.   Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3 above the input represents the signed integer -3.   Follow up: If this function is called many times, how would you optimize it? Solutions: class Solution { public: int hammingWeight(uint32_t n) { int ret = 0; while (n) { n &= n - 1; ++ret; } return ret; } }; "},"leetcode/valid-phone-numbers.html":{"url":"leetcode/valid-phone-numbers.html","title":"193.Valid Phone Numbers","keywords":"","body":"193. Valid Phone Numbers Difficulty: Easy Topics: Similar Questions: Problem: Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890 Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890 Solutions: # Read from the file file.txt and output all valid phone numbers to stdout. grep -e '^[0-9]\\{3\\}-[0-9]\\{3\\}-[0-9]\\{4\\}$' -e '^([0-9]\\{3\\}) [0-9]\\{3\\}-[0-9]\\{4\\}$' file.txt "},"leetcode/house-robber.html":{"url":"leetcode/house-robber.html","title":"198.House Robber","keywords":"","body":"198. House Robber Difficulty: Easy Topics: Dynamic Programming Similar Questions: Maximum Product Subarray House Robber II Paint House Paint Fence House Robber III Non-negative Integers without Consecutive Ones Coin Path Delete and Earn Problem: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).   Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).   Total amount you can rob = 2 + 9 + 1 = 12. Solutions: class Solution { public: int rob(vector& nums) { int n = nums.size(); if (n == 0) return 0; if (n == 1) return nums[0]; vector dp(n, 0); dp[0] = nums[0]; dp[1] = max(nums[1], nums[0]); for (int i = 2; i "},"leetcode/binary-tree-right-side-view.html":{"url":"leetcode/binary-tree-right-side-view.html","title":"199.Binary Tree Right Side View","keywords":"","body":"199. Binary Tree Right Side View Difficulty: Medium Topics: Tree, Depth-first Search, Breadth-first Search Similar Questions: Populating Next Right Pointers in Each Node Boundary of Binary Tree Problem: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector rightSideView(TreeNode* root) { vector ret; helper(root, 0, ret); return ret; } void helper(TreeNode* root, int level, vector& ret) { if (root == nullptr) return; if (ret.size() == level) ret.push_back(root->val); helper(root->right, level + 1, ret); helper(root->left, level + 1, ret); } }; "},"leetcode/number-of-islands.html":{"url":"leetcode/number-of-islands.html","title":"200.Number of Islands","keywords":"","body":"200. Number of Islands Difficulty: Medium Topics: Depth-first Search, Breadth-first Search, Union Find Similar Questions: Surrounded Regions Walls and Gates Number of Islands II Number of Connected Components in an Undirected Graph Number of Distinct Islands Max Area of Island Problem: Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Solutions: class Solution { public: int numIslands(vector>& grid) { int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; vector> visited(m, vector(n, false)); int count = 0; for (int i = 0; i >& grid, vector>& visited, int m, int n, int i, int j) { if (i = m || j = n || visited[i][j] || grid[i][j] == '0') return; visited[i][j] = true; for (int d = 0; d "},"leetcode/bitwise-and-of-numbers-range.html":{"url":"leetcode/bitwise-and-of-numbers-range.html","title":"201.Bitwise AND of Numbers Range","keywords":"","body":"201. Bitwise AND of Numbers Range Difficulty: Medium Topics: Bit Manipulation Similar Questions: Problem: Given a range [m, n] where 0 Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 Solutions: class Solution { public: int rangeBitwiseAnd(int m, int n) { int ret = 0; stack mBitValues; stack nBitValues; while (m > 0) { mBitValues.push(m&(-m)); m -= m&(-m); } while (n > 0) { nBitValues.push(n&(-n)); n -= n&(-n); } while (!mBitValues.empty() && !nBitValues.empty() && mBitValues.top() == nBitValues.top()) { ret += nBitValues.top(); mBitValues.pop(); nBitValues.pop(); } return ret; } }; "},"leetcode/happy-number.html":{"url":"leetcode/happy-number.html","title":"202.Happy Number","keywords":"","body":"202. Happy Number Difficulty: Easy Topics: Hash Table, Math Similar Questions: Linked List Cycle Add Digits Ugly Number Problem: Write an algorithm to determine if a number is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example:  Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Solutions: class Solution { public: bool isHappy(int n) { if (n seen; int nextVal = 0; for (;;) { nextVal = 0; // reset nextVal while (n > 0) { nextVal += (n%10) * (n%10); n /= 10; } if (nextVal == 1) return true; if (seen.count(nextVal) > 0) return false; seen.insert(nextVal); n = nextVal; } } }; "},"leetcode/remove-linked-list-elements.html":{"url":"leetcode/remove-linked-list-elements.html","title":"203.Remove Linked List Elements","keywords":"","body":"203. Remove Linked List Elements Difficulty: Easy Topics: Linked List Similar Questions: Remove Element Delete Node in a Linked List Problem: Remove all elements from a linked list of integers that have value val. Example: Input: 1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5 Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummy = new ListNode(0); ListNode* tail = dummy; ListNode* next = nullptr; while (head) { next = head->next; if (head->val != val) { tail->next = head; tail = tail->next; tail->next = nullptr; } head = next; } return dummy->next; } }; "},"leetcode/count-primes.html":{"url":"leetcode/count-primes.html","title":"204.Count Primes","keywords":"","body":"204. Count Primes Difficulty: Easy Topics: Hash Table, Math Similar Questions: Ugly Number Ugly Number II Perfect Squares Problem: Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Solutions: class Solution { public: int countPrimes(int n) { if (n valid(n, true); for (int i = 2; i "},"leetcode/isomorphic-strings.html":{"url":"leetcode/isomorphic-strings.html","title":"205.Isomorphic Strings","keywords":"","body":"205. Isomorphic Strings Difficulty: Easy Topics: Hash Table Similar Questions: Word Pattern Problem: Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = \"egg\", t = \"add\" Output: true Example 2: Input: s = \"foo\", t = \"bar\" Output: false Example 3: Input: s = \"paper\", t = \"title\" Output: true Note: You may assume both s and t have the same length. Solutions: class Solution { public: bool isIsomorphic(string s, string t) { unordered_map s2t; unordered_map t2s; if (s.length() != t.length()) return false; for (int i = 0; i 0) { if (s2t[s[i]] != t[i] || t2s.count(t[i]) == 0 || t2s[t[i]] != s[i]) return false; } else { if (t2s.count(t[i]) > 0) return false; s2t[s[i]] = t[i]; t2s[t[i]] = s[i]; } } return true; } }; "},"leetcode/reverse-linked-list.html":{"url":"leetcode/reverse-linked-list.html","title":"206.Reverse Linked List","keywords":"","body":"206. Reverse Linked List Difficulty: Easy Topics: Linked List Similar Questions: Reverse Linked List II Binary Tree Upside Down Palindrome Linked List Problem: Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (head == NULL || head->next == NULL) return head; ListNode* reverseSubList = reverseList(head->next); head->next->next = head; head->next = NULL; return reverseSubList; } }; "},"leetcode/course-schedule.html":{"url":"leetcode/course-schedule.html","title":"207.Course Schedule","keywords":"","body":"207. Course Schedule Difficulty: Medium Topics: Depth-first Search, Breadth-first Search, Graph, Topological Sort Similar Questions: Course Schedule II Graph Valid Tree Minimum Height Trees Course Schedule III Problem: There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take.   To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.   To take course 1 you should have finished course 0, and to take course 0 you should   also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Solutions: class Solution { public: bool canFinish(int numCourses, vector>& prerequisites) { vector> graph(numCourses, vector()); vector visit(numCourses); for (auto a : prerequisites) { graph[a[1]].push_back(a[0]); } for (int i = 0; i >& graph, vector& visit, int i) { if (visit[i] == -1) return false; if (visit[i] == 1) return true; visit[i] = -1; for (auto a : graph[i]) { if (!canFinishDFS(graph, visit, a)) return false; } visit[i] = 1; return true; } }; "},"leetcode/implement-trie-prefix-tree.html":{"url":"leetcode/implement-trie-prefix-tree.html","title":"208.Implement Trie (Prefix Tree)","keywords":"","body":"208. Implement Trie (Prefix Tree) Difficulty: Medium Topics: Design, Trie Similar Questions: Add and Search Word - Data structure design Design Search Autocomplete System Replace Words Implement Magic Dictionary Problem: Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Solutions: class Trie { public: struct TrieNode{ bool isWord; TrieNode* next[26]; TrieNode(bool isWord = false) { this->isWord = isWord; for (int i = 0; i isWord = true; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode* lastNode = findNode(word, false); return lastNode != nullptr && lastNode->isWord; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { return findNode(prefix, false) != nullptr; } private: TrieNode* findNode(string& word, bool modifiable) { TrieNode* cur = root; for (auto& c : word) { if (cur->next[c - 'a'] == nullptr) { if (!modifiable) return nullptr; cur->next[c -'a'] = new TrieNode(false); } cur = cur->next[c - 'a']; } return cur; } TrieNode* root; }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */ "},"leetcode/minimum-size-subarray-sum.html":{"url":"leetcode/minimum-size-subarray-sum.html","title":"209.Minimum Size Subarray Sum","keywords":"","body":"209. Minimum Size Subarray Sum Difficulty: Medium Topics: Array, Two Pointers, Binary Search Similar Questions: Minimum Window Substring Maximum Size Subarray Sum Equals k Maximum Length of Repeated Subarray Problem: Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).  Solutions: class Solution { public: int minSubArrayLen(int s, vector& nums) { int sum = 0; int left = 0; int len = INT_MAX; for (int right = 0; right = s) { len = min(len, right - left + 1); sum -= nums[left]; ++left; } } return len == INT_MAX ? 0 : len; } }; "},"leetcode/house-robber-ii.html":{"url":"leetcode/house-robber-ii.html","title":"213.House Robber II","keywords":"","body":"213. House Robber II Difficulty: Medium Topics: Dynamic Programming Similar Questions: House Robber Paint House Paint Fence House Robber III Non-negative Integers without Consecutive Ones Coin Path Problem: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),   because they are adjacent houses. Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).   Total amount you can rob = 1 + 3 = 4. Solutions: class Solution { public: int rob(vector& nums) { int n = nums.size(); if (nums.size() == 0 ) return 0; if (nums.size() == 1) return nums[0]; // this case is very important. Think about [1]; int maxValue = 0; vector dp(n + 1, 0); dp[0] = 0; dp[1] = nums[0]; for (int i = 2; i "},"leetcode/kth-largest-element-in-an-array.html":{"url":"leetcode/kth-largest-element-in-an-array.html","title":"215.Kth Largest Element in an Array","keywords":"","body":"215. Kth Largest Element in an Array Difficulty: Medium Topics: Divide and Conquer, Heap Similar Questions: Wiggle Sort II Top K Frequent Elements Third Maximum Number Kth Largest Element in a Stream K Closest Points to Origin Problem: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array's length. Solutions: class Solution { public: int findKthLargest(vector& nums, int k) { return helper(nums, 0, nums.size() - 1, nums.size() - k); } int helper(vector& nums, int left, int right, int k) { int oldLeft = left; int oldRight = right; if (left == right && left == k) return nums[k]; int pivotal = nums[left]; while (left pivotal) { --right; } if (left = left) { return helper(nums, left, oldRight, k); } else { return nums[k]; } } }; "},"leetcode/combination-sum-iii.html":{"url":"leetcode/combination-sum-iii.html","title":"216.Combination Sum III","keywords":"","body":"216. Combination Sum III Difficulty: Medium Topics: Array, Backtracking Similar Questions: Combination Sum Problem: Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Solutions: class Solution { public: vector> combinationSum3(int k, int n) { vector path; vector> ret; helper(1, n, k, path, ret); return ret; } void helper(int pos, int target, int k, vector& path, vector>& ret) { if (target "},"leetcode/contains-duplicate.html":{"url":"leetcode/contains-duplicate.html","title":"217.Contains Duplicate","keywords":"","body":"217. Contains Duplicate Difficulty: Easy Topics: Array, Hash Table Similar Questions: Contains Duplicate II Contains Duplicate III Problem: Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true Solutions: class Solution { public: bool containsDuplicate(vector& nums) { unordered_set numSet; for (auto num : nums) { if (numSet.count(num) > 0) { return true; } numSet.insert(num); } return false; } }; "},"leetcode/the-skyline-problem.html":{"url":"leetcode/the-skyline-problem.html","title":"218.The Skyline Problem","keywords":"","body":"218. The Skyline Problem Difficulty: Hard Topics: Divide and Conquer, Heap, Binary Indexed Tree, Segment Tree, Line Sweep Similar Questions: Falling Squares Problem: A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 , and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...] Solutions: class Solution { public: struct Event{ int x; int y; bool up; Event(int x, int y, bool up) { this->x = x; this->y = y; this->up = up; } bool operator event.y; } else { return y > getSkyline(vector>& buildings) { vector events; for (auto& building : buildings) { events.push_back({building[0], building[2], true}); events.push_back({building[1], building[2], false}); } sort(events.begin(), events.end()); multiset> heap; heap.insert(0); vector> ret; for (auto& event : events) { if (event.up) { if (event.y > (*heap.begin())) { ret.push_back({event.x, event.y}); } heap.insert(event.y); } else { int currentHeight = *heap.begin(); auto it = heap.find(event.y); heap.erase(it); if (currentHeight > *heap.begin()) { ret.push_back({event.x, *heap.begin()}); } } } return ret; } }; "},"leetcode/contains-duplicate-ii.html":{"url":"leetcode/contains-duplicate-ii.html","title":"219.Contains Duplicate II","keywords":"","body":"219. Contains Duplicate II Difficulty: Easy Topics: Array, Hash Table Similar Questions: Contains Duplicate Contains Duplicate III Problem: Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false Solutions: class Solution { public: bool containsNearbyDuplicate(vector& nums, int k) { unordered_map valToIndex; for (int i = 0; i 0 && i - valToIndex[nums[i]] "},"leetcode/contains-duplicate-iii.html":{"url":"leetcode/contains-duplicate-iii.html","title":"220.Contains Duplicate III","keywords":"","body":"220. Contains Duplicate III Difficulty: Medium Topics: Sort, Ordered Map Similar Questions: Contains Duplicate Contains Duplicate II Problem: Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false Solutions: class Solution { public: bool containsNearbyAlmostDuplicate(vector& nums, int k, int t) { if (k heap; int initHeapSize = min(long(nums.size()), kl); for (int i = 0; i "},"leetcode/maximal-square.html":{"url":"leetcode/maximal-square.html","title":"221.Maximal Square","keywords":"","body":"221. Maximal Square Difficulty: Medium Topics: Dynamic Programming Similar Questions: Maximal Rectangle Largest Plus Sign Problem: Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Solutions: class Solution { public: int maximalSquare(vector>& matrix) { int m = matrix.size(); if (m == 0) return 0; int n = matrix[0].size(); if (n == 0) return 0; vector> dp(m, vector (n, 0)); for (int i = 0; i "},"leetcode/rectangle-area.html":{"url":"leetcode/rectangle-area.html","title":"223.Rectangle Area","keywords":"","body":"223. Rectangle Area Difficulty: Medium Topics: Math Similar Questions: Rectangle Overlap Problem: Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int. Solutions: class Solution { public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) { return - overlap(A, C, E, G) * overlap(F, H, B, D) + area(C - A, D - B) + area(G - E, H - F); } int overlap(int start1, int end1, int start2, int end2) { if (start1 > start2) { swap(start1, start2); swap(end1, end2); } return min(end1 >= start2 ? end1 - start2 : 0, end2 - start2); } int area(int a, int b) { return a * b; } }; "},"leetcode/basic-calculator.html":{"url":"leetcode/basic-calculator.html","title":"224.Basic Calculator","keywords":"","body":"224. Basic Calculator Difficulty: Hard Topics: Math, Stack Similar Questions: Evaluate Reverse Polish Notation Basic Calculator II Different Ways to Add Parentheses Expression Add Operators Basic Calculator III Problem: Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . Example 1: Input: \"1 + 1\" Output: 2 Example 2: Input: \" 2-1 + 2 \" Output: 3 Example 3: Input: \"(1+(4+5+2)-3)+(6+8)\" Output: 23 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. Solutions: class Solution { public: int calculate(string s) { stack stk; int sign = 1; int val = 0; stk.push(0); for (int i = 0; i "},"leetcode/implement-stack-using-queues.html":{"url":"leetcode/implement-stack-using-queues.html","title":"225.Implement Stack using Queues","keywords":"","body":"225. Implement Stack using Queues Difficulty: Easy Topics: Stack, Design Similar Questions: Implement Queue using Stacks Problem: Implement the following operations of a stack using queues. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty. Example: MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Notes: You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). Solutions: class MyStack { public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { q2.push(x); while (!q1.empty()) { q2.push(q1.front()); q1.pop(); } swap(q1, q2); } /** Removes the element on top of the stack and returns that element. */ int pop() { int val = top(); q1.pop(); return val; } /** Get the top element. */ int top() { return q1.front(); } /** Returns whether the stack is empty. */ bool empty() { return q1.empty(); } private: queue q1; queue q2; }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */ "},"leetcode/invert-binary-tree.html":{"url":"leetcode/invert-binary-tree.html","title":"226.Invert Binary Tree","keywords":"","body":"226. Invert Binary Tree Difficulty: Easy Topics: Tree Similar Questions: Problem: Invert a binary tree. Example: Input: 4 / \\ 2 7 / \\ / \\ 1 3 6 9 Output: 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return NULL; TreeNode* left = invertTree(root->right); TreeNode* right = invertTree(root->left); root->left = left; root->right = right; return root; } }; "},"leetcode/basic-calculator-ii.html":{"url":"leetcode/basic-calculator-ii.html","title":"227.Basic Calculator II","keywords":"","body":"227. Basic Calculator II Difficulty: Medium Topics: String Similar Questions: Basic Calculator Expression Add Operators Basic Calculator III Problem: Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. Example 1: Input: \"3+2*2\" Output: 7 Example 2: Input: \" 3/2 \" Output: 1 Example 3: Input: \" 3+5 / 2 \" Output: 5 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. Solutions: class Solution { public: int calculate(string s) { int sum = 0; int val = 0; char lastChar = '+'; vector v; for (int i = 0; i "},"leetcode/summary-ranges.html":{"url":"leetcode/summary-ranges.html","title":"228.Summary Ranges","keywords":"","body":"228. Summary Ranges Difficulty: Medium Topics: Array Similar Questions: Missing Ranges Data Stream as Disjoint Intervals Problem: Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input: [0,1,2,4,5,7] Output: [\"0->2\",\"4->5\",\"7\"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range. Example 2: Input: [0,2,3,4,6,8,9] Output: [\"0\",\"2->4\",\"6\",\"8->9\"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range. Solutions: class Solution { public: vector summaryRanges(vector& nums) { auto ranges = helper(nums, 0, nums.size() - 1); vector ret; for (auto& range : ranges) { ret.push_back(toString(range)); } return ret; } vector> helper(vector& nums, int left, int right) { if (left > right) return {}; if (long(nums[right]) == long(nums[left]) + right - left) { return {{nums[left], nums[right]}}; } int mid = left + (right - left) / 2; auto leftRange = helper(nums, left, mid); auto rightRange = helper(nums, mid + 1, right); if (!leftRange.empty() && !rightRange.empty()) { auto leftLast = leftRange.back(); leftRange.pop_back(); if (leftLast.second + 1 == rightRange[0].first) { rightRange[0].first = leftLast.first; } else { leftRange.push_back(leftLast); } } leftRange.insert(leftRange.end(), rightRange.begin(), rightRange.end()); return leftRange; } inline string toString(pair range) { return range.first == range.second ? to_string(range.first) : to_string(range.first) + \"->\" + to_string(range.second); } }; "},"leetcode/majority-element-ii.html":{"url":"leetcode/majority-element-ii.html","title":"229.Majority Element II","keywords":"","body":"229. Majority Element II Difficulty: Medium Topics: Array Similar Questions: Majority Element Check If a Number Is Majority Element in a Sorted Array Problem: Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2] Solutions: class Solution { public: vector majorityElement(vector& nums) { int majorityVal[2]; int majorityCount[2] {0, 0}; for (auto& num : nums) { // pay attention to the order of the series of if statements if (majorityCount[0] == 0) { majorityVal[0] = num; majorityCount[0] = 1; } else if (num == majorityVal[0]) { ++majorityCount[0]; } else if (majorityCount[1] == 0) { majorityVal[1] = num; majorityCount[1] = 1; } else if (num == majorityVal[1]) { ++majorityCount[1]; if (majorityCount[1] > majorityCount[0]) { swap(majorityCount[0], majorityCount[1]); swap(majorityVal[0], majorityVal[1]); } } else { --majorityCount[0]; --majorityCount[1]; } } majorityCount[0] = 0; majorityCount[1] = 0; for (auto& num : nums) { if (majorityVal[0] == num) { ++majorityCount[0]; } else if (majorityVal[1] == num) { ++majorityCount[1]; } } vector ret; if (majorityCount[0] > nums.size() / 3) { ret.push_back(majorityVal[0]); } if (majorityCount[1] > nums.size() / 3) { ret.push_back(majorityVal[1]); } return ret; } }; "},"leetcode/kth-smallest-element-in-a-bst.html":{"url":"leetcode/kth-smallest-element-in-a-bst.html","title":"230.Kth Smallest Element in a BST","keywords":"","body":"230. Kth Smallest Element in a BST Difficulty: Medium Topics: Binary Search, Tree Similar Questions: Binary Tree Inorder Traversal Second Minimum Node In a Binary Tree Problem: Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\   2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int kthSmallest(TreeNode* root, int k) { int ret = 0; int count = 0; helper(root, k, ret, count); return ret; } bool helper(TreeNode* root, int k, int& ret, int& count) { if (root == NULL) return false; if (helper(root->left, k, ret, count)) return true; ++count; if (count == k) { ret = root->val; return true; } return helper(root->right, k, ret, count); } }; "},"leetcode/power-of-two.html":{"url":"leetcode/power-of-two.html","title":"231.Power of Two","keywords":"","body":"231. Power of Two Difficulty: Easy Topics: Math, Bit Manipulation Similar Questions: Number of 1 Bits Power of Three Power of Four Problem: Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false Solutions: class Solution { public: bool isPowerOfTwo(int n) { return n > 0 && ((n & (n-1)) == 0); } }; "},"leetcode/implement-queue-using-stacks.html":{"url":"leetcode/implement-queue-using-stacks.html","title":"232.Implement Queue using Stacks","keywords":"","body":"232. Implement Queue using Stacks Difficulty: Easy Topics: Stack, Design Similar Questions: Implement Stack using Queues Problem: Implement the following operations of a queue using stacks. push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty. Example: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false Notes: You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). Solutions: class MyQueue { public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stk1.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { flip(); int val = stk2.top(); stk2.pop(); return val; } /** Get the front element. */ int peek() { flip(); return stk2.top(); } /** Returns whether the queue is empty. */ bool empty() { flip(); return stk2.empty(); } private: void flip() { if (stk2.empty()) { while (!stk1.empty()) { int val = stk1.top(); stk1.pop(); stk2.push(val); } } } stack stk1; stack stk2; }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ "},"leetcode/number-of-digit-one.html":{"url":"leetcode/number-of-digit-one.html","title":"233.Number of Digit One","keywords":"","body":"233. Number of Digit One Difficulty: Hard Topics: Math Similar Questions: Factorial Trailing Zeroes Digit Count in Range Problem: Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6 Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. Solutions: class Solution { public: int countDigitOne(int n) { int origin = n; int ret = 0; int level = 0; int val = 1; while (n > 0) { int last = n % 10; if (last != 1) { ret += count(last, last * val, level); } else { ret += count(last, last * val, level); ret += (origin % (val) + 1); } level++; n /= 10; if (n > 0) val *= 10; } return ret; } private: int count(int mostSig, int num, int level) { if (mostSig == 0) return 0; if (mostSig == 1) return num * 0.1 * level; return num * 0.1 * level + num / mostSig; } }; "},"leetcode/palindrome-linked-list.html":{"url":"leetcode/palindrome-linked-list.html","title":"234.Palindrome Linked List","keywords":"","body":"234. Palindrome Linked List Difficulty: Easy Topics: Linked List, Two Pointers Similar Questions: Palindrome Number Valid Palindrome Reverse Linked List Problem: Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space? Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { ListNode* mid = middlePoint(head); ListNode* half = reverse(mid); //cout val val val val val != half->val) return false; head = head->next; half = half->next; } return true; } ListNode* middlePoint(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast && fast -> next) { fast = fast->next->next; slow = slow->next; } return slow; } ListNode* reverse(ListNode* head) { if (head == NULL) return NULL; ListNode* dummy = new ListNode(0); ListNode* cur = head; ListNode* next = NULL; while (cur) { next = cur->next; cur->next = dummy->next; dummy->next = cur; cur = next; } return dummy->next; } }; "},"leetcode/lowest-common-ancestor-of-a-binary-search-tree.html":{"url":"leetcode/lowest-common-ancestor-of-a-binary-search-tree.html","title":"235.Lowest Common Ancestor of a Binary Search Tree","keywords":"","body":"235. Lowest Common Ancestor of a Binary Search Tree Difficulty: Easy Topics: Tree Similar Questions: Lowest Common Ancestor of a Binary Tree Problem: Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]   Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.   Note: All of the nodes' values will be unique. p and q are different and both values will exist in the BST. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return nullptr; if (root == p || root == q) return root; TreeNode* leftAncestor = lowestCommonAncestor(root->left, p, q); TreeNode* rightAncestor = lowestCommonAncestor(root->right, p, q); if (leftAncestor && rightAncestor) return root; if (leftAncestor) return leftAncestor; return rightAncestor; } }; "},"leetcode/lowest-common-ancestor-of-a-binary-tree.html":{"url":"leetcode/lowest-common-ancestor-of-a-binary-tree.html","title":"236.Lowest Common Ancestor of a Binary Tree","keywords":"","body":"236. Lowest Common Ancestor of a Binary Tree Difficulty: Medium Topics: Tree Similar Questions: Lowest Common Ancestor of a Binary Search Tree Problem: Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]   Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.   Note: All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == NULL) return NULL; if (root == p) return p; if (root == q) return q; TreeNode* leftRet = lowestCommonAncestor(root->left, p, q); TreeNode* rightRet = lowestCommonAncestor(root->right, p, q); if (leftRet == NULL && rightRet == NULL) return NULL; if (leftRet == NULL) return rightRet; if (rightRet == NULL) return leftRet; return root; } }; "},"leetcode/delete-node-in-a-linked-list.html":{"url":"leetcode/delete-node-in-a-linked-list.html","title":"237.Delete Node in a Linked List","keywords":"","body":"237. Delete Node in a Linked List Difficulty: Easy Topics: Linked List Similar Questions: Remove Linked List Elements Problem: Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following:   Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.   Note: The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { node->val = node->next->val; node->next = node->next->next; } }; "},"leetcode/product-of-array-except-self.html":{"url":"leetcode/product-of-array-except-self.html","title":"238.Product of Array Except Self","keywords":"","body":"238. Product of Array Except Self Difficulty: Medium Topics: Array Similar Questions: Trapping Rain Water Maximum Product Subarray Paint House II Problem: Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input: [1,2,3,4] Output: [24,12,8,6] Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) Solutions: class Solution { public: vector productExceptSelf(vector& nums) { int n = nums.size(); vector ret (n, 1); for (int i = n - 2; i >= 0; --i) { ret[i] *= ret[i + 1] * nums[i + 1]; } int product = 1; for (int i = 0; i "},"leetcode/sliding-window-maximum.html":{"url":"leetcode/sliding-window-maximum.html","title":"239.Sliding Window Maximum","keywords":"","body":"239. Sliding Window Maximum Difficulty: Hard Topics: Heap, Sliding Window Similar Questions: Minimum Window Substring Min Stack Longest Substring with At Most Two Distinct Characters Paint House II Problem: Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time? Solutions: class Solution { public: vector maxSlidingWindow(vector& nums, int k) { deque q; for (int i = 0; i ret; for (int i = k - 1; i "},"leetcode/search-a-2d-matrix-ii.html":{"url":"leetcode/search-a-2d-matrix-ii.html","title":"240.Search a 2D Matrix II","keywords":"","body":"240. Search a 2D Matrix II Difficulty: Medium Topics: Binary Search, Divide and Conquer Similar Questions: Search a 2D Matrix Problem: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true. Given target = 20, return false. Solutions: class Solution { public: bool searchMatrix(vector>& matrix, int target) { int m = matrix.size(); if (m == 0) return false; int n = matrix[0].size(); if (n == 0) return false; int i = m - 1; int j = 0; while (i >= 0 && j "},"leetcode/valid-anagram.html":{"url":"leetcode/valid-anagram.html","title":"242.Valid Anagram","keywords":"","body":"242. Valid Anagram Difficulty: Easy Topics: Hash Table, Sort Similar Questions: Group Anagrams Palindrome Permutation Find All Anagrams in a String Problem: Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? Solutions: class Solution { public: bool isAnagram(string s, string t) { if (s.length() != t.length()) return false; int count[26] = {0}; for (auto c : s) { ++count[c - 'a']; } for (auto c : t) { if (--count[c - 'a'] "},"leetcode/shortest-word-distance.html":{"url":"leetcode/shortest-word-distance.html","title":"243.Shortest Word Distance","keywords":"","body":"243. Shortest Word Distance Difficulty: Easy Topics: Array Similar Questions: Shortest Word Distance II Shortest Word Distance III Problem: Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. Example: Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]. Input: word1 = “coding”, word2 = “practice” Output: 3 Input: word1 = \"makes\", word2 = \"coding\" Output: 1 Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. Solutions: class Solution { public: int shortestDistance(vector& words, string word1, string word2) { int index1 = -1; int index2 = -1; int distance = INT_MAX; for (int i = 0; i "},"leetcode/shortest-word-distance-ii.html":{"url":"leetcode/shortest-word-distance-ii.html","title":"244.Shortest Word Distance II","keywords":"","body":"244. Shortest Word Distance II Difficulty: Medium Topics: Hash Table, Design Similar Questions: Merge Two Sorted Lists Shortest Word Distance Shortest Word Distance III Problem: Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. Your method will be called repeatedly many times with different parameters.  Example: Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]. Input: word1 = “coding”, word2 = “practice” Output: 3 Input: word1 = \"makes\", word2 = \"coding\" Output: 1 Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. Solutions: class WordDistance { public: WordDistance(vector& words) { for (int i = 0; i & list1, vector& list2) { int ret = INT_MAX; int pos1 = 0; int pos2 = 0; int last; int lastSource; if (list1[pos1] > wordToIndex; }; /** * Your WordDistance object will be instantiated and called as such: * WordDistance* obj = new WordDistance(words); * int param_1 = obj->shortest(word1,word2); */ "},"leetcode/group-shifted-strings.html":{"url":"leetcode/group-shifted-strings.html","title":"249.Group Shifted Strings","keywords":"","body":"249. Group Shifted Strings Difficulty: Medium Topics: Hash Table, String Similar Questions: Group Anagrams Problem: Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\". We can keep \"shifting\" which forms the sequence: \"abc\" -> \"bcd\" -> ... -> \"xyz\" Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. Example: Input: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], Output: [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\",\"z\"] ] Solutions: class Solution { public: vector> groupStrings(vector& strings) { unordered_map> groups; for (auto& s : strings) { string shift = s; int diff = s[0] - 'a'; for (int i = 0; i > ret; for (auto& entry : groups) { ret.push_back(entry.second); } return ret; } }; "},"leetcode/count-univalue-subtrees.html":{"url":"leetcode/count-univalue-subtrees.html","title":"250.Count Univalue Subtrees","keywords":"","body":"250. Count Univalue Subtrees Difficulty: Medium Topics: Tree Similar Questions: Subtree of Another Tree Longest Univalue Path Problem: Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. Example : Input: root = [5,1,5,5,5,null,5] 5 / \\ 1 5 / \\ \\ 5 5 5 Output: 4 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: struct UniInfo { bool inclusive; int num; UniInfo (bool inclusive, int num) { this->inclusive = inclusive; this->num = num; } }; int countUnivalSubtrees(TreeNode* root) { if (root == nullptr) return 0; auto ret = helper(root); return ret.num; } UniInfo helper(TreeNode* root) { if (root->left == nullptr && root->right == nullptr) return {true, 1}; if (root->left == nullptr) { auto rightInfo = helper(root->right); if (rightInfo.inclusive && root->val == root->right->val) return {true, rightInfo.num + 1}; return {false, rightInfo.num}; } else if (root->right == nullptr) { auto leftInfo = helper(root->left); if (leftInfo.inclusive && root->val == root->left->val) return {true, leftInfo.num + 1}; return {false, leftInfo.num}; } else { auto leftInfo = helper(root->left); auto rightInfo = helper(root->right); if (leftInfo.inclusive && rightInfo.inclusive && root->val == root->left->val && root->val == root->right->val) { return {true, leftInfo.num + rightInfo.num + 1}; } else { return {false, leftInfo.num + rightInfo.num}; } } } }; "},"leetcode/flatten-2d-vector.html":{"url":"leetcode/flatten-2d-vector.html","title":"251.Flatten 2D Vector","keywords":"","body":"251. Flatten 2D Vector Difficulty: Medium Topics: Design Similar Questions: Binary Search Tree Iterator Zigzag Iterator Peeking Iterator Flatten Nested List Iterator Problem: Design and implement an iterator to flatten a 2d vector. It should support the following operations: next and hasNext.   Example: Vector2D iterator = new Vector2D([[1,2],[3],[4]]); iterator.next(); // return 1 iterator.next(); // return 2 iterator.next(); // return 3 iterator.hasNext(); // return true iterator.hasNext(); // return true iterator.next(); // return 4 iterator.hasNext(); // return false   Notes: Please remember to RESET your class variables declared in Vector2D, as static/class variables are persisted across multiple test cases. Please see here for more details. You may assume that next() call will always be valid, that is, there will be at least a next element in the 2d vector when next() is called.   Follow up: As an added challenge, try to code it using only iterators in C++ or iterators in Java. Solutions: class Vector2D { public: Vector2D(vector>& v) { this->v = v; i = 0; j = 0; } int next() { hasNext(); int val = v[i][j]; step(); return val; } bool hasNext() { while (i = v[i].size()) { ++i; j = 0; } } private: vector> v; int i; int j; }; /** * Your Vector2D object will be instantiated and called as such: * Vector2D* obj = new Vector2D(v); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ "},"leetcode/meeting-rooms.html":{"url":"leetcode/meeting-rooms.html","title":"252.Meeting Rooms","keywords":"","body":"252. Meeting Rooms Difficulty: Easy Topics: Sort Similar Questions: Merge Intervals Meeting Rooms II Problem: Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si i), determine if a person could attend all meetings. Example 1: Input: [[0,30],[5,10],[15,20]] Output: false Example 2: Input: [[7,10],[2,4]] Output: true NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solutions: class Solution { public: bool canAttendMeetings(vector>& intervals) { sort(intervals.begin(), intervals.end(), [](vector& lhs, vector& rhs) { return lhs[0] "},"leetcode/meeting-rooms-ii.html":{"url":"leetcode/meeting-rooms-ii.html","title":"253.Meeting Rooms II","keywords":"","body":"253. Meeting Rooms II Difficulty: Medium Topics: Heap, Greedy, Sort Similar Questions: Merge Intervals Meeting Rooms Minimum Number of Arrows to Burst Balloons Car Pooling Problem: Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si i), find the minimum number of conference rooms required. Example 1: Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Example 2: Input: [[7,10],[2,4]] Output: 1 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solutions: class Solution { public: struct MeetingEvent { int time; bool start; MeetingEvent(int time, bool start) { this->time = time; this->start = start; } bool operatortime == event.time) { return !(this->start); } else { return this->time >& intervals) { vector events; for (auto& interval : intervals) { events.push_back({interval[0], true}); events.push_back({interval[1], false}); } sort(events.begin(), events.end()); int count = 0; int ret = 0; for (int i = 0; i "},"leetcode/factor-combinations.html":{"url":"leetcode/factor-combinations.html","title":"254.Factor Combinations","keywords":"","body":"254. Factor Combinations Difficulty: Medium Topics: Backtracking Similar Questions: Combination Sum Problem: Numbers can be regarded as product of its factors. For example, 8 = 2 x 2 x 2; = 2 x 4. Write a function that takes an integer n and return all possible combinations of its factors. Note: You may assume that n is always positive. Factors should be greater than 1 and less than n. Example 1: Input: 1 Output: [] Example 2: Input: 37 Output:[] Example 3: Input: 12 Output: [ [2, 6], [2, 2, 3], [3, 4] ] Example 4: Input: 32 Output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] Solutions: class Solution { public: vector> getFactors(int n) { vector path; vector> ret; for (int i = 2; n / i >= i; ++i) { if (n % i == 0) { path.push_back(i); helper(n/i, i, path, ret); path.pop_back(); } } return ret; } private: void helper(int n, int factor, vector& path, vector>& ret) { if (factor > n) return; for (int i = factor; i "},"leetcode/verify-preorder-sequence-in-binary-search-tree.html":{"url":"leetcode/verify-preorder-sequence-in-binary-search-tree.html","title":"255.Verify Preorder Sequence in Binary Search Tree","keywords":"","body":"255. Verify Preorder Sequence in Binary Search Tree Difficulty: Medium Topics: Stack, Tree Similar Questions: Binary Tree Preorder Traversal Problem: Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree. You may assume each number in the sequence is unique. Consider the following binary search tree:  5 / \\ 2 6 / \\ 1 3 Example 1: Input: [5,2,6,1,3] Output: false Example 2: Input: [5,2,1,3,6] Output: true Follow up: Could you do it using only constant space complexity? Solutions: class Solution { public: bool verifyPreorder(vector& preorder) { stack stk; int lowerBound = INT_MIN; for (auto num : preorder) { if (num "},"leetcode/paint-house.html":{"url":"leetcode/paint-house.html","title":"256.Paint House","keywords":"","body":"256. Paint House Difficulty: Easy Topics: Dynamic Programming Similar Questions: House Robber House Robber II Paint House II Paint Fence Problem: There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses. Note: All costs are positive integers. Example: Input: [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.   Minimum cost: 2 + 5 + 3 = 10. Solutions: class Solution { public: int minCost(vector>& costs) { int n = costs.size(); if (n == 0) return 0; vector> dp(2, vector (3, 0)); dp[0][0] = costs[0][0]; dp[0][1] = costs[0][1]; dp[0][2] = costs[0][2]; for (int i = 1; i "},"leetcode/binary-tree-paths.html":{"url":"leetcode/binary-tree-paths.html","title":"257.Binary Tree Paths","keywords":"","body":"257. Binary Tree Paths Difficulty: Easy Topics: Tree, Depth-first Search Similar Questions: Path Sum II Smallest String Starting From Leaf Problem: Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input: 1 / \\ 2 3 \\ 5 Output: [\"1->2->5\", \"1->3\"] Explanation: All root-to-leaf paths are: 1->2->5, 1->3 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector binaryTreePaths(TreeNode* root) { if (root == NULL) return {}; vector> ret; vector path; helper(root, path, ret); vector strRet; for (auto& intPath : ret) { strRet.push_back(join(intPath)); } return strRet; } void helper(TreeNode* root, vector& path, vector>& ret) { path.push_back(root->val); if (root->left == NULL && root->right == NULL) { ret.push_back(path); path.pop_back(); return; } if (root->left) helper(root->left, path, ret); if (root->right) helper(root->right, path, ret); path.pop_back(); } string join(vector& nums) { stringstream ss; for (int i = 0; i \"; } ss "},"leetcode/add-digits.html":{"url":"leetcode/add-digits.html","title":"258.Add Digits","keywords":"","body":"258. Add Digits Difficulty: Easy Topics: Math Similar Questions: Happy Number Sum of Digits in the Minimum Number Problem: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.   Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? Solutions: class Solution { public: int addDigits(int num) { return 1 + (num - 1) % 9; } }; "},"leetcode/3sum-smaller.html":{"url":"leetcode/3sum-smaller.html","title":"259.3Sum Smaller","keywords":"","body":"259. 3Sum Smaller Difficulty: Medium Topics: Array, Two Pointers Similar Questions: 3Sum 3Sum Closest Valid Triangle Number Two Sum Less Than K Problem: Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 that satisfy the condition nums[i] + nums[j] + nums[k] . Example: Input: nums = [-2,0,1,3], and target = 2 Output: 2 Explanation: Because there are two triplets which sums are less than 2:   [-2,0,1] [-2,0,3] Follow up: Could you solve it in O(n2) runtime? Solutions: class Solution { public: int threeSumSmaller(vector& nums, int target) { if (nums.size() "},"leetcode/single-number-iii.html":{"url":"leetcode/single-number-iii.html","title":"260.Single Number III","keywords":"","body":"260. Single Number III Difficulty: Medium Topics: Bit Manipulation Similar Questions: Single Number Single Number II Problem: Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input: [1,2,1,3,2,5] Output: [3,5] Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? Solutions: class Solution { public: vector singleNumber(vector& nums) { int digest = 0; for (auto& num : nums) { digest ^= num; } // String from the least significant bit, the first bit set to 1 digest &= (-digest); vector ret(2, 0); for (auto& num : nums) { if (num & digest) { ret[0] ^= num; } else { ret[1] ^= num; } } return ret; } }; "},"leetcode/graph-valid-tree.html":{"url":"leetcode/graph-valid-tree.html","title":"261.Graph Valid Tree","keywords":"","body":"261. Graph Valid Tree Difficulty: Medium Topics: Depth-first Search, Breadth-first Search, Union Find, Graph Similar Questions: Course Schedule Number of Connected Components in an Undirected Graph Problem: Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. Example 1: Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]] Output: true Example 2: Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]] Output: false Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges. Solutions: class Solution { public: bool validTree(int n, vector>& edges) { vector> graph (n); for (auto& edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } int edgeNum = edges.size(); if (edgeNum != n - 1) return false; vector visited(n, false); int nodeCount = getConnectedNode(0, graph, visited); return nodeCount == n; } int getConnectedNode(int start, vector>& graph, vector& visited) { if (visited[start]) return 0; int count = 1; visited[start] = true; for (auto& neighbor : graph[start]) { count += getConnectedNode(neighbor, graph, visited); } return count; } }; "},"leetcode/ugly-number.html":{"url":"leetcode/ugly-number.html","title":"263.Ugly Number","keywords":"","body":"263. Ugly Number Difficulty: Easy Topics: Math Similar Questions: Happy Number Count Primes Ugly Number II Problem: Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3: Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1]. Solutions: class Solution { public: bool isUgly(int num) { if (num "},"leetcode/ugly-number-ii.html":{"url":"leetcode/ugly-number-ii.html","title":"264.Ugly Number II","keywords":"","body":"264. Ugly Number II Difficulty: Medium Topics: Math, Dynamic Programming, Heap Similar Questions: Merge k Sorted Lists Count Primes Ugly Number Perfect Squares Super Ugly Number Problem: Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:   1 is typically treated as an ugly number. n does not exceed 1690. Solutions: class Solution { public: struct UglyNumber{ int val; int prime; int index; UglyNumber(int val, int prime, int index) { this->val = val; this->prime = prime; this->index = index; } bool operator>(const UglyNumber& other) const { return val*prime > other.val*other.prime; } }; int nthUglyNumber(int n) { vector primes {2, 3, 5}; vector dp(n, 0); dp[0] = 1; priority_queue, greater> pq; for (auto prime : primes) { pq.push({1, prime, 0}); } for (int i = 1; i "},"leetcode/paint-house-ii.html":{"url":"leetcode/paint-house-ii.html","title":"265.Paint House II","keywords":"","body":"265. Paint House II Difficulty: Hard Topics: Dynamic Programming Similar Questions: Product of Array Except Self Sliding Window Maximum Paint House Paint Fence Problem: There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses. Note: All costs are positive integers. Example: Input: [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5;   Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. Follow up: Could you solve it in O(nk) runtime? Solutions: class Solution { public: int minCostII(vector>& costs) { int n = costs.size(); if (n == 0) return 0; int k = costs[0].size(); if (k == 0) return 0; if (k == 1) { // check the situation when there is only one color. if (n == 1) return costs[0][0]; return -1; } costs.push_back(vector(k, 0)); ++n; vector> dp (n + 1, vector(k, 0)); int least1 = 0; int color1 = -1; int least2 = 0; int color2 = -1; for (int i = 1; i "},"leetcode/palindrome-permutation.html":{"url":"leetcode/palindrome-permutation.html","title":"266.Palindrome Permutation","keywords":"","body":"266. Palindrome Permutation Difficulty: Easy Topics: Hash Table Similar Questions: Longest Palindromic Substring Valid Anagram Palindrome Permutation II Longest Palindrome Problem: Given a string, determine if a permutation of the string could form a palindrome. Example 1: Input: \"code\" Output: false Example 2: Input: \"aab\" Output: true Example 3: Input: \"carerac\" Output: true Solutions: class Solution { public: bool canPermutePalindrome(string s) { int charCount[256] = {0}; for (auto c : s) { charCount[c] ^= 0x1; } int count = 0; for (int i = 0; i "},"leetcode/missing-number.html":{"url":"leetcode/missing-number.html","title":"268.Missing Number","keywords":"","body":"268. Missing Number Difficulty: Easy Topics: Array, Math, Bit Manipulation Similar Questions: First Missing Positive Single Number Find the Duplicate Number Couples Holding Hands Problem: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Solutions: class Solution { public: int missingNumber(vector& nums) { int n = nums.size(); for (int i = 0; i & nums, int i) { int val = nums[i]; nums[i] = -1; while (val = 0) { swap(val, nums[val]); } } }; "},"leetcode/alien-dictionary.html":{"url":"leetcode/alien-dictionary.html","title":"269.Alien Dictionary","keywords":"","body":"269. Alien Dictionary Difficulty: Hard Topics: Graph, Topological Sort Similar Questions: Course Schedule II Problem: There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. Example 1: Input: [ \"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\" ] Output: \"wertf\" Example 2: Input: [ \"z\", \"x\" ] Output: \"zx\" Example 3: Input: [ \"z\", \"x\", \"z\" ] Output: \"\"  Explanation: The order is invalid, so return \"\". Note: You may assume all letters are in lowercase. You may assume that if a is a prefix of b, then a must appear before b in the given dictionary. If the order is invalid, return an empty string. There may be multiple valid order of letters, return any one of them is fine. Solutions: class Solution { public: string alienOrder(vector& words) { unordered_map> graph; unordered_map inDegree; for (int i = 0; i partialOrder = getPartialOrder(words[i], words[i+1]); if (partialOrder.size() == 0) continue; graph[partialOrder[0]].push_back(partialOrder[1]); ++inDegree[partialOrder[1]]; } string ret; queue q; for (auto& node : graph) { if (inDegree.count(node.first) == 0) { // it is wrong to iterate inDegree directly, becaues for those free chars, it is not in inDegree. q.push(node.first); } } while (!q.empty()) { char c = q.front(); q.pop(); ret.push_back(c); for (auto& neighbor : graph[c]) { if(--inDegree[neighbor] == 0) { q.push(neighbor); } } } for (auto& node : inDegree) { if (node.second != 0) return \"\"; } return ret; } vector getPartialOrder(string& smaller, string& larger) { for (int i = 0; i "},"leetcode/closest-binary-search-tree-value.html":{"url":"leetcode/closest-binary-search-tree-value.html","title":"270.Closest Binary Search Tree Value","keywords":"","body":"270. Closest Binary Search Tree Value Difficulty: Easy Topics: Binary Search, Tree Similar Questions: Count Complete Tree Nodes Closest Binary Search Tree Value II Search in a Binary Search Tree Problem: Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target. Note: Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target. Example: Input: root = [4,2,5,1,3], target = 3.714286 4 / \\ 2 5 / \\ 1 3 Output: 4 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int closestValue(TreeNode* root, double target) { int ret = root->val; if (root->left) { int leftClose = closestValue(root->left, target); if (abs(ret - target) > abs(leftClose - target)) { ret = leftClose; } } if (root->right) { int rightClose = closestValue(root->right, target); if (abs(ret - target) > abs(rightClose - target)) { ret = rightClose; } } return ret; } }; "},"leetcode/encode-and-decode-strings.html":{"url":"leetcode/encode-and-decode-strings.html","title":"271.Encode and Decode Strings","keywords":"","body":"271. Encode and Decode Strings Difficulty: Medium Topics: String Similar Questions: Count and Say Serialize and Deserialize Binary Tree String Compression Count Binary Substrings Problem: Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: string encode(vector strs) { // ... your code return encoded_string; } Machine 2 (receiver) has the function: vector decode(string s) { //... your code return strs; } So Machine 1 does: string encoded_string = encode(strs); and Machine 2 does: vector strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods.   Note: The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters. Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless. Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm. Solutions: class Codec { public: // Encodes a list of strings to a single string. string encode(vector& strs) { string serial; int n = strs.size(); serial.append(writeInt(n)); for (int i = 0; i decode(string s) { vector strs; const char* buf = s.c_str(); int n = readInt(buf); for (int i = 0; i "},"leetcode/closest-binary-search-tree-value-ii.html":{"url":"leetcode/closest-binary-search-tree-value-ii.html","title":"272.Closest Binary Search Tree Value II","keywords":"","body":"272. Closest Binary Search Tree Value II Difficulty: Hard Topics: Stack, Tree Similar Questions: Binary Tree Inorder Traversal Closest Binary Search Tree Value Problem: Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target. Note: Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. Example: Input: root = [4,2,5,1,3], target = 3.714286, and k = 2 4 / \\ 2 5 / \\ 1 3 Output: [4,3] Follow up: Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)? Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Iterator{ public: Iterator(stack stk, bool forward): stk_(stk), forward_(forward) { } int next() { TreeNode* node = stk_.top(); stk_.pop(); int ret = node->val; node = forward_ ? node->right : node->left; while (node) { stk_.push(node); node = forward_ ? node->left : node->right; } return ret; } // remember to has peek() int peek() { return stk_.top()->val; } bool hasNext() { return !stk_.empty(); } private: bool forward_; stack stk_; }; class Solution { public: vector closestKValues(TreeNode* root, double target, int k) { if (k == 0) return {}; if (root == NULL) return {}; stack fstk; stack bstk; findHelper(root, target, fstk, bstk); Iterator forwardIter = Iterator(fstk, true); Iterator backIter = Iterator(bstk, false); if (forwardIter.peek() ret; for (int i = 0; i & fstk, stack& bstk) { if (double(root->val) == target) { fstk.push(root); bstk.push(root); return; } if (double(root->val) > target) { if (root->left) { fstk.push(root); findHelper(root->left, target, fstk, bstk); return; } fstk.push(root); bstk.push(root); return; } if (double(root->val) right) { bstk.push(root); findHelper(root->right, target, fstk, bstk); return; } fstk.push(root); bstk.push(root); return; } } }; "},"leetcode/integer-to-english-words.html":{"url":"leetcode/integer-to-english-words.html","title":"273.Integer to English Words","keywords":"","body":"273. Integer to English Words Difficulty: Hard Topics: Math, String Similar Questions: Integer to Roman Problem: Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: \"One Hundred Twenty Three\" Example 2: Input: 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Example 4: Input: 1234567891 Output: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\" Solutions: class Solution { public: string numberToWords(int num) { if (num == 0) return \"Zero\"; string ret; if (num >= 1000000000) { ret += lessThousand(num / 1000000000) + \" Billion \"; num = num % 1000000000; } if (num >= 1000000) { ret += lessThousand(num / 1000000) + \" Million \"; num = num % 1000000; } if (num >= 1000) { ret += lessThousand(num / 1000) + \" Thousand \"; num = num % 1000; } ret += lessThousand(num); if (ret.back() == ' ') { ret.pop_back(); } return ret; } private: string lessThousand(int num) { string twenty[] {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}; string hundred[] {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; string ret; if (num / 100 > 0) { ret = twenty[num / 100] + \" \" + \"Hundred \"; num = num % 100; } if (num >= 20) { ret += hundred[num/10 - 2] + \" \"; num = num % 10; } if (num > 0) { ret += twenty[num]; } if (ret.length() > 0 && ret.back() == ' ') { ret.pop_back(); } return ret; } }; "},"leetcode/h-index.html":{"url":"leetcode/h-index.html","title":"274.H-Index","keywords":"","body":"274. H-Index Difficulty: Medium Topics: Hash Table, Sort Similar Questions: H-Index II Problem: Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\" Example: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.   Since the researcher has 3 papers with at least 3 citations each and the remaining   two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Solutions: class Solution { public: int hIndex(vector& citations) { sort(citations.begin(), citations.end()); int left = 0; int right = citations.size(); // not size - 1 while (left & citations, int h) { if (h == 0) return true; int n = citations.size(); return citations[n - h] >= h; } }; "},"leetcode/h-index-ii.html":{"url":"leetcode/h-index-ii.html","title":"275.H-Index II","keywords":"","body":"275. H-Index II Difficulty: Medium Topics: Binary Search Similar Questions: H-Index Problem: Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\" Example: Input: citations = [0,1,3,5,6] Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.   Since the researcher has 3 papers with at least 3 citations each and the remaining   two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up: This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity? Solutions: class Solution { public: int hIndex(vector& citations) { int left = 0; int right = citations.size(); // not size - 1 while (left & citations, int h) { if (h == 0) return true; int n = citations.size(); return citations[n - h] >= h; } }; "},"leetcode/paint-fence.html":{"url":"leetcode/paint-fence.html","title":"276.Paint Fence","keywords":"","body":"276. Paint Fence Difficulty: Easy Topics: Dynamic Programming Similar Questions: House Robber House Robber II Paint House Paint House II Problem: There is a fence with n posts, each post can be painted with one of the k colors. You have to paint all the posts such that no more than two adjacent fence posts have the same color. Return the total number of ways you can paint the fence. Note: n and k are non-negative integers. Example: Input: n = 3, k = 2 Output: 6 Explanation: Take c1 as color 1, c2 as color 2. All possible ways are:   post1 post2 post3 ----- ----- ----- ----- 1 c1 c1 c2   2 c1 c2 c1   3 c1 c2 c2   4 c2 c1 c1  5 c2 c1 c2   6 c2 c2 c1 Solutions: class Solution { public: int numWays(int n, int k) { if (k == 0) return 0; if (n == 0) return 0; return k * helper(n - 1, k); } int helper(int n, int k) { if (n == 0) return 1; if (n == 1) return k; int a = 1; int b = k; for (int i = 2; i "},"leetcode/find-the-celebrity.html":{"url":"leetcode/find-the-celebrity.html","title":"277.Find the Celebrity","keywords":"","body":"277. Find the Celebrity Difficulty: Medium Topics: Array Similar Questions: Find the Town Judge Problem: Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n). There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.   Example 1: Input: graph = [   [1,1,0],   [0,1,0],   [1,1,1] ] Output: 1 Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody. Example 2: Input: graph = [   [1,0,1],   [1,1,0],   [0,1,1] ] Output: -1 Explanation: There is no celebrity.   Note: The directed graph is represented as an adjacency matrix, which is an n x n matrix where a[i][j] = 1 means person i knows person j while a[i][j] = 0 means the contrary. Remember that you won't have direct access to the adjacency matrix. Solutions: // Forward declaration of the knows API. bool knows(int a, int b); class Solution { public: int findCelebrity(int n) { return findCandidate(n); } private: int findCandidate(int n) { unordered_set candidates; for (int i = 0; i "},"leetcode/first-bad-version.html":{"url":"leetcode/first-bad-version.html","title":"278.First Bad Version","keywords":"","body":"278. First Bad Version Difficulty: Easy Topics: Binary Search Similar Questions: Find First and Last Position of Element in Sorted Array Search Insert Position Guess Number Higher or Lower Problem: You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version.  Solutions: // Forward declaration of isBadVersion API. bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int left = 1; int right = n; while (left + 1 "},"leetcode/perfect-squares.html":{"url":"leetcode/perfect-squares.html","title":"279.Perfect Squares","keywords":"","body":"279. Perfect Squares Difficulty: Medium Topics: Math, Dynamic Programming, Breadth-first Search Similar Questions: Count Primes Ugly Number II Problem: Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Solutions: class Solution { public: int numSquares(int n) { queue q; unordered_set visited; q.push(n); visited.insert(n); int level = 0; while(true) { ++level; int size = q.size(); for (int i = 0; i 0) continue; visited.insert(remaining); q.push(remaining); } } } return -1; } }; "},"leetcode/wiggle-sort.html":{"url":"leetcode/wiggle-sort.html","title":"280.Wiggle Sort","keywords":"","body":"280. Wiggle Sort Difficulty: Medium Topics: Array, Sort Similar Questions: Sort Colors Wiggle Sort II Problem: Given an unsorted array nums, reorder it in-place such that nums[0] = nums[2] . Example: Input: nums = [3,5,2,1,6,4] Output: One possible answer is [3,5,1,6,2,4] Solutions: class Solution { public: void wiggleSort(vector& nums) { for (int i = 1; i nums[i-1]) { swap(nums[i], nums[i-1]); } } } } }; "},"leetcode/zigzag-iterator.html":{"url":"leetcode/zigzag-iterator.html","title":"281.Zigzag Iterator","keywords":"","body":"281. Zigzag Iterator Difficulty: Medium Topics: Design Similar Questions: Binary Search Tree Iterator Flatten 2D Vector Peeking Iterator Flatten Nested List Iterator Problem: Given two 1d vectors, implement an iterator to return their elements alternately. Example: Input: v1 = [1,2] v2 = [3,4,5,6] Output: [1,3,2,4,5,6] Explanation: By calling next repeatedly until hasNext returns false,   the order of elements returned by next should be: [1,3,2,4,5,6]. Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases? Clarification for the follow up question: The \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\". For example: Input: [1,2,3] [4,5,6,7] [8,9] Output: [1,4,8,2,5,9,3,6,7]. Solutions: class ZigzagIterator { public: ZigzagIterator(vector& v1, vector& v2) { this->v1 = v1; this->v2 = v2; } int next() { if (pos1 == v1.size()) { return v2[pos2++]; } if (pos2 == v2.size()) { return v1[pos1++]; } if ((pos1 + pos2) % 2 == 0) { return v1[pos1++]; } else { return v2[pos2++]; } } bool hasNext() { return pos1 v1; vector v2; }; /** * Your ZigzagIterator object will be instantiated and called as such: * ZigzagIterator i(v1, v2); * while (i.hasNext()) cout "},"leetcode/move-zeroes.html":{"url":"leetcode/move-zeroes.html","title":"283.Move Zeroes","keywords":"","body":"283. Move Zeroes Difficulty: Easy Topics: Array, Two Pointers Similar Questions: Remove Element Problem: Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Solutions: class Solution { public: void moveZeroes(vector& nums) { int len = 0; for (int i = 0; i "},"leetcode/peeking-iterator.html":{"url":"leetcode/peeking-iterator.html","title":"284.Peeking Iterator","keywords":"","body":"284. Peeking Iterator Difficulty: Medium Topics: Design Similar Questions: Binary Search Tree Iterator Flatten 2D Vector Zigzag Iterator Problem: Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). Example: Assume that the iterator is initialized to the beginning of the list: [1,2,3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. Follow up: How would you extend your design to be generic and work with all types, not just integer? Solutions: // Below is the interface for Iterator, which is already defined for you. // **DO NOT** modify the interface for Iterator. class Iterator { struct Data; Data* data; public: Iterator(const vector& nums); Iterator(const Iterator& iter); virtual ~Iterator(); // Returns the next element in the iteration. int next(); // Returns true if the iteration has more elements. bool hasNext() const; }; class PeekingIterator : public Iterator { public: PeekingIterator(const vector& nums) : Iterator(nums) { // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods. if (Iterator::hasNext()) { val = Iterator::next(); end = false; } else { end = true; } } // Returns the next element in the iteration without advancing the iterator. int peek() { return val; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { if (!Iterator::hasNext()) { end = true; return val; } int ret = val; val = Iterator::next(); return ret; } bool hasNext() const { return !end; } private: int val; bool end; }; "},"leetcode/inorder-successor-in-bst.html":{"url":"leetcode/inorder-successor-in-bst.html","title":"285.Inorder Successor in BST","keywords":"","body":"285. Inorder Successor in BST Difficulty: Medium Topics: Tree Similar Questions: Binary Tree Inorder Traversal Binary Search Tree Iterator Inorder Successor in BST II Problem: Given a binary search tree and a node in it, find the in-order successor of that node in the BST. The successor of a node p is the node with the smallest key greater than p.val.   Example 1: Input: root = [2,1,3], p = 1 Output: 2 Explanation: 1's in-order successor node is 2. Note that both p and the return value is of TreeNode type. Example 2: Input: root = [5,3,6,2,4,null,null,1], p = 6 Output: null Explanation: There is no in-order successor of the current node, so the answer is null.   Note: If the given node has no in-order successor in the tree, return null. It's guaranteed that the values of the tree are unique. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if (root == NULL || p == NULL) return NULL; if (root->val val) { return inorderSuccessor(root->right, p); } else { TreeNode* ret = inorderSuccessor(root->left, p); return ret == NULL ? root : ret; } } }; "},"leetcode/walls-and-gates.html":{"url":"leetcode/walls-and-gates.html","title":"286.Walls and Gates","keywords":"","body":"286. Walls and Gates Difficulty: Medium Topics: Breadth-first Search Similar Questions: Surrounded Regions Number of Islands Shortest Distance from All Buildings Robot Room Cleaner Rotting Oranges Problem: You are given a m x n 2D grid initialized with these three possible values. -1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF. Example:  Given the 2D grid: INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be: 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 Solutions: class Solution { public: void wallsAndGates(vector>& rooms) { int INF = INT_MAX; queue> q; int m = rooms.size(); if (m == 0) return; int n = rooms[0].size(); if (n == 0) return; for (int i = 0; i = m || col = n || rooms[row][col] != INF) continue; rooms[row][col] = distance; q.push({row + 1, col}); q.push({row - 1, col}); q.push({row, col - 1}); q.push({row, col + 1}); } } } }; "},"leetcode/unique-word-abbreviation.html":{"url":"leetcode/unique-word-abbreviation.html","title":"288.Unique Word Abbreviation","keywords":"","body":"288. Unique Word Abbreviation Difficulty: Medium Topics: Hash Table, Design Similar Questions: Two Sum III - Data structure design Generalized Abbreviation Problem: An abbreviation of a word follows the form . Below are some examples of word abbreviations: a) it --> it (no abbreviation) 1 ↓ b) d|o|g --> d1g 1 1 1 1---5----0----5--8 ↓ ↓ ↓ ↓ ↓ c) i|nternationalizatio|n --> i18n 1 1---5----0   ↓ ↓ ↓ d) l|ocalizatio|n --> l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation. Example: Given dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ] isUnique(\"dear\") -> false isUnique(\"cart\") -> true isUnique(\"cane\") -> false isUnique(\"make\") -> true Solutions: class ValidWordAbbr { public: ValidWordAbbr(vector& dictionary) { words.insert(dictionary.begin(), dictionary.end()); for (const auto& word : words) { string abbr = toAbbr(word); ++wordAbbrFreq[abbr]; } } bool isUnique(const string& word) { if (words.count(word) > 0) { return wordAbbrFreq[toAbbr(word)] == 1; } else { return wordAbbrFreq.find(toAbbr(word)) == wordAbbrFreq.end(); } } private: string toAbbr(const string& str) { string abbr; abbr.push_back(str[0]); if (str.length() > 2) { abbr.append(to_string(str.length() - 2)); } if (str.length() > 1) { abbr.push_back(str.back()); } return abbr; } unordered_set words; unordered_map wordAbbrFreq; }; /** * Your ValidWordAbbr object will be instantiated and called as such: * ValidWordAbbr* obj = new ValidWordAbbr(dictionary); * bool param_1 = obj->isUnique(word); */ "},"leetcode/word-pattern.html":{"url":"leetcode/word-pattern.html","title":"290.Word Pattern","keywords":"","body":"290. Word Pattern Difficulty: Easy Topics: Hash Table Similar Questions: Isomorphic Strings Word Pattern II Problem: Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = \"abba\", str = \"dog cat cat dog\" Output: true Example 2: Input:pattern = \"abba\", str = \"dog cat cat fish\" Output: false Example 3: Input: pattern = \"aaaa\", str = \"dog cat cat dog\" Output: false Example 4: Input: pattern = \"abba\", str = \"dog dog dog dog\" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space. Solutions: class Solution { public: bool wordPattern(string pattern, string str) { unordered_map patternToString; unordered_map stringToPattern; int pos = 0; for (int i = 0; i "},"leetcode/nim-game.html":{"url":"leetcode/nim-game.html","title":"292.Nim Game","keywords":"","body":"292. Nim Game Difficulty: Easy Topics: Brainteaser, Minimax Similar Questions: Flip Game II Problem: You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false Explanation: If there are 4 stones in the heap, then you will never win the game;   No matter 1, 2, or 3 stones you remove, the last stone will always be   removed by your friend. Solutions: class Solution { public: bool canWinNim(int n) { return n % 4 != 0; } }; "},"leetcode/flip-game.html":{"url":"leetcode/flip-game.html","title":"293.Flip Game","keywords":"","body":"293. Flip Game Difficulty: Easy Topics: String Similar Questions: Flip Game II Problem: You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. Example: Input: s = \"++++\" Output: [ \"--++\", \"+--+\", \"++--\" ] Note: If there is no valid move, return an empty list []. Solutions: class Solution { public: vector generatePossibleNextMoves(string s) { vector ret; for (int i = 0; i "},"leetcode/flip-game-ii.html":{"url":"leetcode/flip-game-ii.html","title":"294.Flip Game II","keywords":"","body":"294. Flip Game II Difficulty: Medium Topics: Backtracking, Minimax Similar Questions: Nim Game Flip Game Guess Number Higher or Lower II Can I Win Problem: You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win. Example: Input: s = \"++++\" Output: true Explanation: The starting player can guarantee a win by flipping the middle \"++\" to become \"+--+\". Follow up: Derive your algorithm's runtime complexity. Solutions: class Solution { public: bool canWin(string s) { unordered_map cache; return helper(s, cache); } private: bool helper(string& s, unordered_map& cache) { if (cache.count(s) > 0) return cache[s]; for (int i = 0; i "},"leetcode/find-median-from-data-stream.html":{"url":"leetcode/find-median-from-data-stream.html","title":"295.Find Median from Data Stream","keywords":"","body":"295. Find Median from Data Stream Difficulty: Hard Topics: Heap, Design Similar Questions: Sliding Window Median Problem: Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far.   Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2   Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Solutions: class MedianFinder { public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { v2.insert(num); if (v2.size() - v1.size() > 1) { auto it = v2.begin(); v1.insert(*it); v2.erase(it); } if (v1.size() > 0 && *v1.rbegin() > *v2.begin()) { int val1 = *v1.rbegin(); int val2 = *v2.begin(); v1.erase(--v1.end()); v2.erase(v2.begin()); v1.insert(val2); v2.insert(val1); } } double findMedian() { return v2.size() > v1.size() ? *v2.begin() : ((double) *v1.rbegin() + (double) *v2.begin()) / 2; } private: multiset v1; multiset v2; }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ "},"leetcode/best-meeting-point.html":{"url":"leetcode/best-meeting-point.html","title":"296.Best Meeting Point","keywords":"","body":"296. Best Meeting Point Difficulty: Hard Topics: Math, Sort Similar Questions: Shortest Distance from All Buildings Minimum Moves to Equal Array Elements II Problem: A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. Example: Input: 1 - 0 - 0 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 Output: 6 Explanation: Given three people living at (0,0), (0,4), and (2,2):   The point (0,2) is an ideal meeting point, as the total travel distance   of 2+2+2=6 is minimal. So return 6. Solutions: class Solution { public: int minTotalDistance(vector>& grid) { int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; vector x, y; for (int i = 0; i & points) { // it is median!!! not average!!! int distance = 0; int i = 0; int j = points.size() - 1; while (i "},"leetcode/serialize-and-deserialize-binary-tree.html":{"url":"leetcode/serialize-and-deserialize-binary-tree.html","title":"297.Serialize and Deserialize Binary Tree","keywords":"","body":"297. Serialize and Deserialize Binary Tree Difficulty: Hard Topics: Tree, Design Similar Questions: Encode and Decode Strings Serialize and Deserialize BST Find Duplicate Subtrees Serialize and Deserialize N-ary Tree Problem: Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5 as \"[1,2,3,null,null,4,5]\" Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string ret; serializeHelper(root, ret); return ret; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { int pos = 0; return deserializeHelper(data, pos); } private: void serializeHelper(TreeNode* root, string& ret) { const static string NULL_STRING = \"NULL\"; if (root == nullptr) { ret.append(NULL_STRING); ret.push_back(' '); return; } ret.append(to_string(root->val)); ret.push_back(' '); serializeHelper(root->left, ret); serializeHelper(root->right, ret); } TreeNode* deserializeHelper(string& data, int& pos) { string token = getToken(data, pos); if (token == \"NULL\") { return nullptr; } TreeNode* root = new TreeNode(stoi(token)); root->left = deserializeHelper(data, pos); root->right = deserializeHelper(data, pos); return root; } string getToken(string& data, int& pos) { string ret; for (;data[pos] != ' '; ++pos) { ret.push_back(data[pos]); } ++pos; // remove space return ret; } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.deserialize(codec.serialize(root)); "},"leetcode/smallest-rectangle-enclosing-black-pixels.html":{"url":"leetcode/smallest-rectangle-enclosing-black-pixels.html","title":"302.Smallest Rectangle Enclosing Black Pixels","keywords":"","body":"302. Smallest Rectangle Enclosing Black Pixels Difficulty: Hard Topics: Binary Search Similar Questions: Problem: An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels. Example: Input: [ \"0010\", \"0110\", \"0100\" ] and x = 0, y = 2 Output: 6 Solutions: class Solution { public: int minArea(vector>& image, int x, int y) { int m = image.size(); if (m == 0) return 0; int n = image[0].size(); if (n == 0) return 0; int up = searchByRow(image, 0, x, m, n, true); int down = searchByRow(image, x, m - 1, m, n, false); int right = searchByColumn(image, y, n - 1, m, n, true); int left = searchByColumn(image, 0, y, m, n, false); return (down - up + 1) * (right - left + 1); } private: int searchByRow(vector>& image, int up, int down, int m, int n, bool upwards) { while (up + 1 >& image, int left, int right, int m, int n, bool forwards) { while (left + 1 >& image, int row, int m, int n) { for (int i = 0; i >& image, int col, int m, int n) { for (int i = 0; i "},"leetcode/range-sum-query-mutable.html":{"url":"leetcode/range-sum-query-mutable.html","title":"307.Range Sum Query - Mutable","keywords":"","body":"307. Range Sum Query - Mutable Difficulty: Medium Topics: Binary Indexed Tree, Segment Tree Similar Questions: Range Sum Query - Immutable Range Sum Query 2D - Mutable Problem: Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5] sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. Solutions: class NumArray { public: NumArray(vector& nums) { int n = nums.size(); bits = vector (n+1 , 0); this->nums = vector (n, 0); // don't reuse the name for (int i = 0; i 0) { sum += bits[i]; i -= lowbit(i); } return sum; } int sumRange(int i, int j) { return sum(j + 1) - sum(i); } inline int lowbit(int i) { return i & (-i); } private: vector bits; vector nums; }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj->update(i,val); * int param_2 = obj->sumRange(i,j); */ "},"leetcode/super-ugly-number.html":{"url":"leetcode/super-ugly-number.html","title":"313.Super Ugly Number","keywords":"","body":"313. Super Ugly Number Difficulty: Medium Topics: Math, Heap Similar Questions: Ugly Number II Problem: Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32 Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19] of size 4. Note: 1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 k ≤ 100, 0 n ≤ 106, 0 primes[i] The nth super ugly number is guaranteed to fit in a 32-bit signed integer. Solutions: class Solution { public: struct UglyNumber{ int val; int prime; int index; UglyNumber(int val, int prime, int index) { this->val = val; this->prime = prime; this->index = index; } bool operator>(const UglyNumber& other) const { return val*prime > other.val*other.prime; } }; int nthSuperUglyNumber(int n, vector& primes) { vector dp(n, 0); dp[0] = 1; priority_queue, greater> pq; for (auto prime : primes) { pq.push({1, prime, 0}); } for (int i = 1; i "},"leetcode/count-of-smaller-numbers-after-self.html":{"url":"leetcode/count-of-smaller-numbers-after-self.html","title":"315.Count of Smaller Numbers After Self","keywords":"","body":"315. Count of Smaller Numbers After Self Difficulty: Hard Topics: Binary Search, Divide and Conquer, Sort, Binary Indexed Tree, Segment Tree Similar Questions: Count of Range Sum Queue Reconstruction by Height Reverse Pairs Problem: You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Solutions: class Solution { public: class BIT { public: BIT(int upper) { nums.resize(upper + 1); upperBound = upper; } void add(int index) { while (index 0) { sum += nums[index]; index -= lowerBit(index); } return sum; } inline int lowerBit(int i) { return i & (-i); } private: int upperBound; vector nums; }; vector countSmaller(vector& nums) { if (nums.size() == 0) return {}; int smallest = *min_element(nums.begin(), nums.end()); int offset = 0; if (smallest ret(n); for (int i = n - 1; i >= 0; --i) { int val = nums[i] + offset; ret[i] = bit.query(val-1); // query is tricky! bit.add(val); } return ret; } }; "},"leetcode/bulb-switcher.html":{"url":"leetcode/bulb-switcher.html","title":"319.Bulb Switcher","keywords":"","body":"319. Bulb Switcher Difficulty: Medium Topics: Math, Brainteaser Similar Questions: Bulb Switcher II Minimum Number of K Consecutive Bit Flips Problem: There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on. Solutions: class Solution { public: int bulbSwitch(int n) { return sqrt(n); } }; "},"leetcode/power-of-three.html":{"url":"leetcode/power-of-three.html","title":"326.Power of Three","keywords":"","body":"326. Power of Three Difficulty: Easy Topics: Math Similar Questions: Power of Two Power of Four Problem: Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion? Solutions: class Solution { public: bool isPowerOfThree(int n) { if (n "},"leetcode/odd-even-linked-list.html":{"url":"leetcode/odd-even-linked-list.html","title":"328.Odd Even Linked List","keywords":"","body":"328. Odd Even Linked List Difficulty: Medium Topics: Linked List Similar Questions: Split Linked List in Parts Problem: Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ... Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* oddEvenList(ListNode* head) { ListNode* evenDummyHead = new ListNode(0); ListNode* oddDummyHead = new ListNode(0); ListNode* evenCur = evenDummyHead; ListNode* oddCur = oddDummyHead; ListNode* cur = head; int count = 0; while (cur) { if (count % 2 == 0) { evenCur->next = cur; evenCur = evenCur->next; } else { oddCur->next = cur; oddCur = oddCur->next; } cur = cur->next; ++count; } evenCur->next = oddDummyHead->next; oddCur->next = NULL; return evenDummyHead->next; } }; "},"leetcode/longest-increasing-path-in-a-matrix.html":{"url":"leetcode/longest-increasing-path-in-a-matrix.html","title":"329.Longest Increasing Path in a Matrix","keywords":"","body":"329. Longest Increasing Path in a Matrix Difficulty: Hard Topics: Depth-first Search, Topological Sort, Memoization Similar Questions: Problem: Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2: Input: nums = [ [3,4,5], [3,2,6], [2,2,1] ] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. Solutions: class Solution { public: int longestIncreasingPath(vector>& matrix) { unordered_map memory; int m = matrix.size(); if (m == 0) return 0; int n = matrix[0].size(); if (n == 0) return 0; int ret = 0; for (int row = 0; row >&matrix, int m , int n, int row, int col, unordered_map& memory) { int coord = n * row + col; if (memory.count(coord) > 0) { return memory[coord]; } else { int maxPathLen = 1; for (int d = 0; d = m || nextCol = n) continue; if (matrix[nextRow][nextCol] "},"leetcode/increasing-triplet-subsequence.html":{"url":"leetcode/increasing-triplet-subsequence.html","title":"334.Increasing Triplet Subsequence","keywords":"","body":"334. Increasing Triplet Subsequence Difficulty: Medium Topics: Similar Questions: Longest Increasing Subsequence Problem: Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k such that arr[i] arr[j] arr[k] given 0 ≤ i j k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity. Example 1: Input: [1,2,3,4,5] Output: true Example 2: Input: [5,4,3,2,1] Output: false Solutions: class Solution { public: bool increasingTriplet(vector& nums) { int smallest = INT_MAX; int secondSmallest = INT_MAX; for (auto num : nums) { if (num "},"leetcode/counting-bits.html":{"url":"leetcode/counting-bits.html","title":"338.Counting Bits","keywords":"","body":"338. Counting Bits Difficulty: Medium Topics: Dynamic Programming, Bit Manipulation Similar Questions: Number of 1 Bits Problem: Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. Solutions: class Solution { public: vector countBits(int num) { vector ret(num + 1, 0); for (int i = 1; i "},"leetcode/power-of-four.html":{"url":"leetcode/power-of-four.html","title":"342.Power of Four","keywords":"","body":"342. Power of Four Difficulty: Easy Topics: Bit Manipulation Similar Questions: Power of Two Power of Three Problem: Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true Example 2: Input: 5 Output: false Follow up: Could you solve it without loops/recursion? Solutions: class Solution { public: bool isPowerOfFour(int num) { return num > 0 && ((num & (num - 1)) == 0) && ((num & 0x55555555) != 0); } }; "},"leetcode/reverse-string.html":{"url":"leetcode/reverse-string.html","title":"344.Reverse String","keywords":"","body":"344. Reverse String Difficulty: Easy Topics: Two Pointers, String Similar Questions: Reverse Vowels of a String Reverse String II Problem: Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters.   Example 1: Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] Solutions: class Solution { public: void reverseString(vector& s) { int left = 0; int right = s.size() - 1; while (left "},"leetcode/moving-average-from-data-stream.html":{"url":"leetcode/moving-average-from-data-stream.html","title":"346.Moving Average from Data Stream","keywords":"","body":"346. Moving Average from Data Stream Difficulty: Easy Topics: Design, Queue Similar Questions: Problem: Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Example: MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3   Solutions: class MovingAverage { public: /** Initialize your data structure here. */ MovingAverage(int size) { capacity = size; } double next(int val) { nums.push(val); sum += val; if (nums.size() > capacity) { sum -= nums.front(); nums.pop(); } return (double) sum / nums.size(); } private: int sum = 0; queue nums; int capacity; }; /** * Your MovingAverage object will be instantiated and called as such: * MovingAverage* obj = new MovingAverage(size); * double param_1 = obj->next(val); */ "},"leetcode/top-k-frequent-elements.html":{"url":"leetcode/top-k-frequent-elements.html","title":"347.Top K Frequent Elements","keywords":"","body":"347. Top K Frequent Elements Difficulty: Medium Topics: Hash Table, Heap Similar Questions: Word Frequency Kth Largest Element in an Array Sort Characters By Frequency Split Array into Consecutive Subsequences Top K Frequent Words K Closest Points to Origin Problem: Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Solutions: class Solution { public: vector topKFrequent(vector& nums, int k) { for (auto num : nums) { ++counts[num]; } set> topKIndex; for (auto it = counts.begin(); it != counts.end(); ++it) { topKIndex.insert({it->second, it->first}); if (topKIndex.size() > k) { topKIndex.erase(topKIndex.begin()); } } vector ret; for (auto it = topKIndex.rbegin(); it != topKIndex.rend(); ++it) { ret.push_back(it->second); } return ret; } private: unordered_map counts; }; "},"leetcode/intersection-of-two-arrays-ii.html":{"url":"leetcode/intersection-of-two-arrays-ii.html","title":"350.Intersection of Two Arrays II","keywords":"","body":"350. Intersection of Two Arrays II Difficulty: Easy Topics: Hash Table, Two Pointers, Binary Search, Sort Similar Questions: Intersection of Two Arrays Find Common Characters Problem: Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Solutions: class Solution { public: vector intersect(vector& nums1, vector& nums2) { if (nums1.size() > nums2.size()) { return intersect(nums2, nums1); } unordered_multiset numSet(nums1.begin(), nums1.end()); vector ret; for (auto num : nums2) { auto it = numSet.find(num); if (it != numSet.end()) { ret.push_back(num); numSet.erase(it); } } return ret; } }; "},"leetcode/valid-perfect-square.html":{"url":"leetcode/valid-perfect-square.html","title":"367.Valid Perfect Square","keywords":"","body":"367. Valid Perfect Square Difficulty: Easy Topics: Math, Binary Search Similar Questions: Sqrt(x) Sum of Square Numbers Problem: Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16 Output: true Example 2: Input: 14 Output: false Solutions: class Solution { public: bool isPerfectSquare(int num) { int left = 1; // left is 1! int right = INT_MAX; while (left mid) { left = mid + 1; } else { right = mid; } } return num % left == 0 && num / left == left; } }; "},"leetcode/sum-of-two-integers.html":{"url":"leetcode/sum-of-two-integers.html","title":"371.Sum of Two Integers","keywords":"","body":"371. Sum of Two Integers Difficulty: Easy Topics: Bit Manipulation Similar Questions: Add Two Numbers Problem: Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = -2, b = 3 Output: 1 Solutions: class Solution { public: int getSum(int a, int b) { int ret = a^b; int carry = a&b; while (carry != 0) { carry = (carry & 0x7fffffff) "},"leetcode/super-pow.html":{"url":"leetcode/super-pow.html","title":"372.Super Pow","keywords":"","body":"372. Super Pow Difficulty: Medium Topics: Math Similar Questions: Pow(x, n) Problem: Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1: Input: a = 2, b = [3] Output: 8 Example 2: Input: a = 2, b = [1,0] Output: 1024 Solutions: class Solution { public: int superPow(int a, vector& b) { int ret = 1; int base = a % MOD; // a need to mod first! for (auto it = b.rbegin(); it != b.rend(); ++it) { int digit = *it; ret = ret * pow(base, digit) % MOD; base = pow(base, 10); } return ret; } private: int pow(int val, int n) { int ret = 1; int power = val; for (int i = 0; i > i) & 1) { ret = ret * power % MOD; } power = (power * power) % MOD; } return ret; } static const int MOD = 1337; }; "},"leetcode/guess-number-higher-or-lower.html":{"url":"leetcode/guess-number-higher-or-lower.html","title":"374.Guess Number Higher or Lower","keywords":"","body":"374. Guess Number Higher or Lower Difficulty: Easy Topics: Binary Search Similar Questions: First Bad Version Guess Number Higher or Lower II Find K Closest Elements Problem: We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example : Input: n = 10, pick = 6 Output: 6 Solutions: // Forward declaration of guess API. // @param num, your guess // @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); class Solution { public: int guessNumber(int n) { int left = 1; int right = n; while (left "},"leetcode/insert-delete-getrandom-o1.html":{"url":"leetcode/insert-delete-getrandom-o1.html","title":"380.Insert Delete GetRandom O(1)","keywords":"","body":"380. Insert Delete GetRandom O(1) Difficulty: Medium Topics: Array, Hash Table, Design Similar Questions: Insert Delete GetRandom O(1) - Duplicates allowed Problem: Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet(); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1); // Returns false as 2 does not exist in the set. randomSet.remove(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2); // getRandom should return either 1 or 2 randomly. randomSet.getRandom(); // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1); // 2 was already in the set, so return false. randomSet.insert(2); // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom(); Solutions: class RandomizedSet { public: /** Initialize your data structure here. */ RandomizedSet() { tail = 0; } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if (numToIndex.count(val) > 0) return false; if (tail == nums.size()) { nums.push_back(val); numToIndex[val] = tail; ++tail; } else { nums[tail] = val; numToIndex[val] = tail; ++tail; } return true; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if (numToIndex.count(val) == 0) return false; int lastValue = nums[tail - 1]; int index = numToIndex[val]; swap(nums[index], nums[tail - 1]); numToIndex[lastValue] = index; --tail; numToIndex.erase(val); return true; } /** Get a random element from the set. */ int getRandom() { int rIndex = rand() % tail; return nums[rIndex]; } private: vector nums; int tail; unordered_map numToIndex; }; /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj->insert(val); * bool param_2 = obj->remove(val); * int param_3 = obj->getRandom(); */ "},"leetcode/shuffle-an-array.html":{"url":"leetcode/shuffle-an-array.html","title":"384.Shuffle an Array","keywords":"","body":"384. Shuffle an Array Difficulty: Medium Topics: Similar Questions: Problem: Shuffle a set of numbers without duplicates. Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to its original configuration [1,2,3]. solution.reset(); // Returns the random shuffling of array [1,2,3]. solution.shuffle(); Solutions: class Solution { public: Solution(vector& nums) { this->nums = nums; } /** Resets the array to its original configuration and return it. */ vector reset() { return nums; } /** Returns a random shuffling of the array. */ vector shuffle() { vector ret(nums.begin(), nums.end()); for (int i = 0; i nums; }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector param_1 = obj->reset(); * vector param_2 = obj->shuffle(); */ "},"leetcode/mini-parser.html":{"url":"leetcode/mini-parser.html","title":"385.Mini Parser","keywords":"","body":"385. Mini Parser Difficulty: Medium Topics: String, Stack Similar Questions: Flatten Nested List Iterator Ternary Expression Parser Remove Comments Problem: Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ]. Example 1: Given s = \"324\", You should return a NestedInteger object which contains a single integer 324. Example 2: Given s = \"[123,[456,[789]]]\", Return a NestedInteger object containing a nested list with 2 elements: An integer containing value 123. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. Solutions: /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Constructor initializes an empty nested list. * NestedInteger(); * * // Constructor initializes a single integer. * NestedInteger(int value); * * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Set this NestedInteger to hold a single integer. * void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * void add(const NestedInteger &ni); * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector &getList() const; * }; */ class Solution { public: NestedInteger deserialize(string s) { int pos = 0; return helper(s, pos); } NestedInteger base(string&s, int& pos) { int sign = 1; if (s[pos] == '-') { sign = -1; ++pos; } int val = s[pos] - '0'; while (pos + 1 "},"leetcode/first-unique-character-in-a-string.html":{"url":"leetcode/first-unique-character-in-a-string.html","title":"387.First Unique Character in a String","keywords":"","body":"387. First Unique Character in a String Difficulty: Easy Topics: Hash Table, String Similar Questions: Sort Characters By Frequency Problem: Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1. Examples: s = \"leetcode\" return 0. s = \"loveleetcode\", return 2. Note: You may assume the string contain only lowercase letters. Solutions: class Solution { public: int firstUniqChar(string s) { int count[26] = {0}; for (int i = 0; i "},"leetcode/fizz-buzz.html":{"url":"leetcode/fizz-buzz.html","title":"412.Fizz Buzz","keywords":"","body":"412. Fizz Buzz Difficulty: Easy Topics: Similar Questions: Problem: Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15, Return: [ \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\" ] Solutions: class Solution { public: vector fizzBuzz(int n) { vector ret; for (int i = 1; i "},"leetcode/path-sum-iii.html":{"url":"leetcode/path-sum-iii.html","title":"437.Path Sum III","keywords":"","body":"437. Path Sum III Difficulty: Easy Topics: Tree Similar Questions: Path Sum Path Sum II Path Sum IV Longest Univalue Path Problem: You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 5 -> 3 5 -> 2 -> 1 -3 -> 11 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int pathSum(TreeNode* root, int sum) { if (root == nullptr) return 0; return helper(root, sum, 0) + pathSum(root->left, sum) + pathSum(root->right, sum); } int helper(TreeNode* root, int sum, int path) { if (root == nullptr) return 0; int count = 0; count += ((sum == path + root->val) ? 1 : 0); count += helper(root->left, sum, path + root->val); count += helper(root->right, sum, path + root->val); return count; } }; "},"leetcode/ternary-expression-parser.html":{"url":"leetcode/ternary-expression-parser.html","title":"439.Ternary Expression Parser","keywords":"","body":"439. Ternary Expression Parser Difficulty: Medium Topics: Stack, Depth-first Search Similar Questions: Mini Parser Remove Comments Parse Lisp Expression Problem: Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively). Note: The length of the given string is ≤ 10000. Each number will contain only one digit. The conditional expressions group right-to-left (as usual in most languages). The condition will always be either T or F. That is, the condition will never be a digit. The result of the expression will always evaluate to either a digit 0-9, T or F. Example 1: Input: \"T?2:3\" Output: \"2\" Explanation: If true, then result is 2; otherwise result is 3. Example 2: Input: \"F?1:T?4:5\" Output: \"4\" Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: \"(F ? 1 : (T ? 4 : 5))\" \"(F ? 1 : (T ? 4 : 5))\" -> \"(F ? 1 : 4)\" or -> \"(T ? 4 : 5)\" -> \"4\" -> \"4\" Example 3: Input: \"T?T?F:5:3\" Output: \"F\" Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: \"(T ? (T ? F : 5) : 3)\" \"(T ? (T ? F : 5) : 3)\" -> \"(T ? F : 3)\" or -> \"(T ? F : 5)\" -> \"F\" -> \"F\" Solutions: class Solution { public: string parseTernary(string expression) { if (expression.length() == 0) return \"\"; int pos = 0; return helper(expression, pos); } string helper(string& expression, int& pos) { char c = expression[pos]; if ((c == 'T' || c == 'F') && (pos + 1 "},"leetcode/sequence-reconstruction.html":{"url":"leetcode/sequence-reconstruction.html","title":"444.Sequence Reconstruction","keywords":"","body":"444. Sequence Reconstruction Difficulty: Medium Topics: Graph, Topological Sort Similar Questions: Course Schedule II Problem: Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 104. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence. Example 1: Input: org: [1,2,3], seqs: [[1,2],[1,3]] Output: false Explanation: [1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed. Example 2: Input: org: [1,2,3], seqs: [[1,2]] Output: false Explanation: The reconstructed sequence can only be [1,2]. Example 3: Input: org: [1,2,3], seqs: [[1,2],[1,3],[2,3]] Output: true Explanation: The sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3]. Example 4: Input: org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]] Output: true UPDATE (2017/1/8): The seqs parameter had been changed to a list of list of strings (instead of a 2d array of strings). Please reload the code definition to get the latest changes. Solutions: class Solution { public: bool sequenceReconstruction(vector& org, vector>& seqs) { unordered_map> nodeToNeighbors; unordered_map dependencyCount; for (auto seq : seqs) { for (auto num : seq) { nodeToNeighbors[num] = {}; dependencyCount[num] = 0; } } if (nodeToNeighbors.size() != org.size()) return false; for (auto seq : seqs) { for (int i = 1; i q; for (auto nodeCountInfo : dependencyCount) { if (nodeCountInfo.second == 0) { q.push(nodeCountInfo.first); } } while (!q.empty()) { int size = q.size(); if (size != 1) return false; int num = q.front(); q.pop(); for (auto node : nodeToNeighbors[num]) { if ((--dependencyCount[node]) == 0 ) { q.push(node); } } } for (auto nodeCountInfo : dependencyCount) { if (nodeCountInfo.second != 0) return false; } return true; } }; "},"leetcode/serialize-and-deserialize-bst.html":{"url":"leetcode/serialize-and-deserialize-bst.html","title":"449.Serialize and Deserialize BST","keywords":"","body":"449. Serialize and Deserialize BST Difficulty: Medium Topics: Tree Similar Questions: Serialize and Deserialize Binary Tree Find Duplicate Subtrees Serialize and Deserialize N-ary Tree Problem: Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string s; serializeHelper(root, s); return s; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { int pos = 0; return deserializeHelper(data, pos, INT_MAX); } TreeNode* deserializeHelper(string& data, int& pos, int upper) { if (pos * sizeof(int) == data.length()) return NULL; int val = *((reinterpret_cast (data.data())) + pos); // data.data()! if (val > upper) return NULL; TreeNode* root = new TreeNode(val); pos += 1; root->left = deserializeHelper(data, pos, val - 1); root->right = deserializeHelper(data, pos, upper); return root; } void serializeHelper(TreeNode* root, string& s) { if (root == NULL) return; s.append(reinterpret_cast(&root->val), sizeof(root->val)); serializeHelper(root->left, s); serializeHelper(root->right, s); } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.deserialize(codec.serialize(root)); "},"leetcode/delete-node-in-a-bst.html":{"url":"leetcode/delete-node-in-a-bst.html","title":"450.Delete Node in a BST","keywords":"","body":"450. Delete Node in a BST Difficulty: Medium Topics: Tree Similar Questions: Split BST Problem: Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3 5 / \\ 3 6 / \\ \\ 2 4 7 Given key to delete is 3. So we find the node with value 3 and delete it. One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \\ 4 6 / \\ 2 7 Another valid answer is [5,2,6,null,4,null,7]. 5 / \\ 2 6 \\ \\ 4 7 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (root == NULL) return NULL; if (key val) { root->left = deleteNode(root->left, key); } else if (key > root->val) { root->right = deleteNode(root->right, key); } else { if (root->left == NULL) { return root->right; } if (root->right == NULL) { return root->left; } TreeNode* prev = root; TreeNode* cur = root->right; while(cur->left) { prev = cur; cur = cur->left; } // it is very important to have this check if (prev == root) prev->right = cur->right; else prev->left = cur->right; TreeNode* newRoot = cur; newRoot->left = root->left; newRoot->right = root->right; root = newRoot; } return root; } }; "},"leetcode/hamming-distance.html":{"url":"leetcode/hamming-distance.html","title":"461.Hamming Distance","keywords":"","body":"461. Hamming Distance Difficulty: Easy Topics: Bit Manipulation Similar Questions: Number of 1 Bits Total Hamming Distance Problem: The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y 31. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. Solutions: class Solution { public: int hammingDistance(int x, int y) { int diff = x ^ y; int count = 0; while (diff) { diff &= diff - 1; ++count; } return count; } }; "},"leetcode/convex-polygon.html":{"url":"leetcode/convex-polygon.html","title":"469.Convex Polygon","keywords":"","body":"469. Convex Polygon Difficulty: Medium Topics: Math Similar Questions: Problem: Given a list of points that form a polygon when joined sequentially, find if this polygon is convex (Convex polygon definition).   Note: There are at least 3 and at most 10,000 points. Coordinates are in the range -10,000 to 10,000. You may assume the polygon formed by given points is always a simple polygon (Simple polygon definition). In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise don't intersect each other.   Example 1: [[0,0],[0,1],[1,1],[1,0]] Answer: True Explanation: Example 2: [[0,0],[0,10],[10,10],[10,0],[5,5]] Answer: False Explanation: Solutions: class Solution { public: bool isConvex(vector>& points) { int direction = 0; int n = points.size(); for (int i = 0; i & a, vector& b, vector& c) { vector v1 = {b[0] - a[0], b[1] - a[1]}; vector v2 = {c[0] - b[0], c[1] - b[1]}; int prodDiff = v1[0] * v2[1] - v1[1] * v2[0]; if (prodDiff > 0) return 1; else if (prodDiff "},"leetcode/base-7.html":{"url":"leetcode/base-7.html","title":"504.Base 7","keywords":"","body":"504. Base 7 Difficulty: Easy Topics: Similar Questions: Problem: Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: \"202\" Example 2: Input: -7 Output: \"-10\" Note: The input will be in range of [-1e7, 1e7]. Solutions: class Solution { public: string convertToBase7(int num) { if (num == 0) return \"0\"; int sign = 1; if (num 0) { ret.push_back('0' + num % 7); num /= 7; } if (sign == -1) { ret.push_back('-'); } reverse(ret.begin(), ret.end()); return ret; } }; "},"leetcode/k-diff-pairs-in-an-array.html":{"url":"leetcode/k-diff-pairs-in-an-array.html","title":"532.K-diff Pairs in an Array","keywords":"","body":"532. K-diff Pairs in an Array Difficulty: Easy Topics: Array, Two Pointers Similar Questions: Minimum Absolute Difference in BST Problem: Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1). Note: The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7]. Solutions: class Solution { public: int findPairs(vector& nums, int k) { sort(nums.begin(), nums.end()); int count = 0; int j = 0; for (int i = 1; i k) { ++j; } if (j "},"leetcode/array-partition-i.html":{"url":"leetcode/array-partition-i.html","title":"561.Array Partition I","keywords":"","body":"561. Array Partition I Difficulty: Easy Topics: Array Similar Questions: Problem: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. Solutions: class Solution { public: int arrayPairSum(vector& nums) { sort(nums.begin(), nums.end()); int sum = 0; for (int i = 0; i "},"leetcode/permutation-in-string.html":{"url":"leetcode/permutation-in-string.html","title":"567.Permutation in String","keywords":"","body":"567. Permutation in String Difficulty: Medium Topics: Two Pointers, Sliding Window Similar Questions: Minimum Window Substring Find All Anagrams in a String Problem: Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.   Example 1: Input: s1 = \"ab\" s2 = \"eidbaooo\" Output: True Explanation: s2 contains one permutation of s1 (\"ba\"). Example 2: Input:s1= \"ab\" s2 = \"eidboaoo\" Output: False   Note: The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000]. Solutions: class Solution { public: bool isPermutation(string s1, string s2) { if (s1.length() != s2.length()) return false; int count[26] = {0}; for (char c : s1) { ++count[c - 'a']; } for (char c : s2) { if (--count[c - 'a'] charHash; for (int i = 0; i "},"leetcode/valid-triangle-number.html":{"url":"leetcode/valid-triangle-number.html","title":"611.Valid Triangle Number","keywords":"","body":"611. Valid Triangle Number Difficulty: Medium Topics: Array Similar Questions: 3Sum Smaller Problem: Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are: 2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3 Note: The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000]. Solutions: class Solution { public: int triangleNumber(vector& nums) { if (nums.size() bIndex) { count += (cIndex - bIndex); } } } return count; } }; "},"leetcode/find-k-closest-elements.html":{"url":"leetcode/find-k-closest-elements.html","title":"658.Find K Closest Elements","keywords":"","body":"658. Find K Closest Elements Difficulty: Medium Topics: Binary Search Similar Questions: Guess Number Higher or Lower Guess Number Higher or Lower II Find K-th Smallest Pair Distance Problem: Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1: Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4] Example 2: Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4] Note: The value k is positive and will always be smaller than the length of the sorted array. Length of the given array is positive and will not exceed 104 Absolute value of elements in the array and x will not exceed 104 UPDATE (2017/9/19): The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes. Solutions: class Solution { public: vector findClosestElements(vector& arr, int k, int x) { int startIndex = findClosest(arr, x); if (startIndex ret; int forward, backward; if (arr[startIndex] == x) { ret.push_back(arr[startIndex]); --k; forward = startIndex + 1; backward = startIndex - 1; } else if (arr[startIndex] > x){ forward = startIndex; backward = startIndex - 1; } else { forward = startIndex + 1; backward = startIndex; } while (k > 0) { if (forward >= arr.size()) { ret.push_back(arr[backward--]); --k; } else if (backward & arr, int target) { int left = 0; int right = arr.size() - 1; while (left "},"leetcode/path-sum-iv.html":{"url":"leetcode/path-sum-iv.html","title":"666.Path Sum IV","keywords":"","body":"666. Path Sum IV Difficulty: Medium Topics: Tree Similar Questions: Path Sum Path Sum II Binary Tree Maximum Path Sum Path Sum III Problem: If the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers. For each integer in this list: The hundreds digit represents the depth D of this node, 1 The tens digit represents the position P of this node in the level it belongs to, 1 . The position is the same as that in a full binary tree. The units digit represents the value V of this node, 0   Given a list of ascending three-digits integers representing a binary tree with the depth smaller than 5, you need to return the sum of all paths from the root towards the leaves. Example 1: Input: [113, 215, 221] Output: 12 Explanation: The tree that the list represents is: 3 / \\ 5 1 The path sum is (3 + 5) + (3 + 1) = 12.   Example 2: Input: [113, 221] Output: 4 Explanation: The tree that the list represents is: 3 \\ 1 The path sum is (3 + 1) = 4.   Solutions: class Solution { public: int pathSum(vector& nums) { if (nums.size() == 0) return 0; sort(nums.begin(), nums.end()); int curLevel = 0; vector curLevelVals = {0}; vector lastLevelVals; vector> tree; for (auto num : nums) { int level = num/100; int pos = (num - level * 100)/10; int val = num % 10; if (level != curLevel) { tree.push_back(lastLevelVals); lastLevelVals = curLevelVals; curLevelVals.clear(); curLevelVals.resize(1 "},"leetcode/next-closest-time.html":{"url":"leetcode/next-closest-time.html","title":"681.Next Closest Time","keywords":"","body":"681. Next Closest Time Difficulty: Medium Topics: String Similar Questions: Problem: Given a time represented in the format \"HH:MM\", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused. You may assume the given input string is always valid. For example, \"01:34\", \"12:09\" are all valid. \"1:34\", \"12:9\" are all invalid. Example 1: Input: \"19:34\" Output: \"19:39\" Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later. It is not 19:33, because this occurs 23 hours and 59 minutes later. Example 2: Input: \"23:59\" Output: \"22:22\" Explanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically. Solutions: class Solution { public: string nextClosestTime(string time) { set digitSet; for (auto c : time) { if (c != ':') { digitSet.insert(c); } } vector digits (digitSet.begin(), digitSet.end()); ++time[4]; char nextChar = next(digits, time[4]); if (nextChar != '#') { time[4] = nextChar; return time; } else { time[4] = digits[0]; } ++time[3]; nextChar = next(digits, time[3]); if (nextChar != '#') { time[3] = nextChar; if (time[3] '3') { time[1] = digits[0]; } else { return time; } } else { time[1] = digits[0]; } ++time[0]; nextChar = next(digits, time[0]); if (nextChar != '#') { time[0] = nextChar; if (time[0] > '2') { time[0] = digits[0]; } else { return time; } } else { time[0] = digits[0]; } return time; } char next(vector& digits, char c) { auto it = lower_bound(digits.begin(), digits.end(), c); if (it != digits.end()) { return *it; } else { return '#'; } } }; "},"leetcode/redundant-connection.html":{"url":"leetcode/redundant-connection.html","title":"684.Redundant Connection","keywords":"","body":"684. Redundant Connection Difficulty: Medium Topics: Tree, Union Find, Graph Similar Questions: Redundant Connection II Accounts Merge Problem: In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u , that represents an undirected edge connecting nodes u and v. Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u . Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this: 1 / \\ 2 - 3 Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused. Solutions: class Solution { public: class UF { public: bool isConnected(int a, int b) { return findParents(a) == findParents(b); } void connect(int a, int b) { int rootA = findParents(a); int rootB = findParents(b); parents[rootA] = rootB; } int findParents(int a) { if (parents.count(a) == 0 || parents[a] == a) { // check whether parents[a] == a; otherwise infinite resursion. parents[a] = a; } else { parents[a] = findParents(parents[a]); } return parents[a]; } private: unordered_map parents; }; vector findRedundantConnection(vector>& edges) { UF uf; for (auto& edge : edges) { if (uf.isConnected(edge[0], edge[1])) return edge; else { uf.connect(edge[0], edge[1]); } } return {}; } }; "},"leetcode/1-bit-and-2-bit-characters.html":{"url":"leetcode/1-bit-and-2-bit-characters.html","title":"717.1-bit and 2-bit Characters","keywords":"","body":"717. 1-bit and 2-bit Characters Difficulty: Easy Topics: Array Similar Questions: Gray Code Problem: We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input: bits = [1, 0, 0] Output: True Explanation: The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: Input: bits = [1, 1, 1, 0] Output: False Explanation: The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 . bits[i] is always 0 or 1. Solutions: class Solution { public: bool isOneBitCharacter(vector& bits) { bool oneBit; for (int i = 0; i "},"leetcode/remove-comments.html":{"url":"leetcode/remove-comments.html","title":"722.Remove Comments","keywords":"","body":"722. Remove Comments Difficulty: Medium Topics: String Similar Questions: Mini Parser Ternary Expression Parser Problem: Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code. This represents the result of splitting the original source code string by the newline character \\n. In C++, there are two types of comments, line comments, and block comments. The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored. The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning. The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored. If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty. There will be no control characters, single quote, or double quote characters. For example, source = \"string s = \"/* Not a comment. */\";\" will not be a test case. (Also, nothing else such as defines or macros will interfere with the comments.) It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment. Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details. After removing the comments from the source code, return the source code in the same format. Example 1: Input: source = [\"/*Test program */\", \"int main()\", \"{ \", \" // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \" multiline \", \" comment for \", \" testing */\", \"a = b + c;\", \"}\"] The line by line code is visualized as below: /*Test program */ int main() { // variable declaration int a, b, c; /* This is a test multiline comment for testing */ a = b + c; } Output: [\"int main()\",\"{ \",\" \",\"int a, b, c;\",\"a = b + c;\",\"}\"] The line by line code is visualized as below: int main() { int a, b, c; a = b + c; } Explanation: The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments. Example 2: Input: source = [\"a/*comment\", \"line\", \"more_comment*/b\"] Output: [\"ab\"] Explanation: The original source string is \"a/*comment\\nline\\nmore_comment*/b\", where we have bolded the newline characters. After deletion, the implicit newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"]. Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code. Solutions: class Solution { public: vector removeComments(vector& source) { queue buffer; bool inContext = false; vector ret; for (auto& line : source) { auto processed = processLine(buffer, line, inContext); addLine(buffer, processed, ret); } return ret; } private: string processLine(queue& buffer, string& line, bool& inContext) { string ret; for (int i = 0; i & buffer, string& line, vector& ret) { for (auto c : line) { if (c != '\\n') { buffer.push(c); } else { string str; while (!buffer.empty()) { str.push_back(buffer.front()); buffer.pop(); } ret.push_back(str); } } } }; "},"leetcode/my-calendar-i.html":{"url":"leetcode/my-calendar-i.html","title":"729.My Calendar I","keywords":"","body":"729. My Calendar I Difficulty: Medium Topics: Array Similar Questions: My Calendar II My Calendar III Problem: Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start . A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation: The first event can be booked. The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.   Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].   Solutions: class MyCalendar { public: struct Interval { int start; int end; Interval(int start, int end) { this->start = start; this->end = end; } bool operatorend) return false; it = next(it); } if (it != intervals.end()) { if (interval.end > it->start) return false; else { intervals.insert(interval); return true; } } else { intervals.insert(interval); return true; } } private: set intervals; }; /** * Your MyCalendar object will be instantiated and called as such: * MyCalendar* obj = new MyCalendar(); * bool param_1 = obj->book(start,end); */ "},"leetcode/flood-fill.html":{"url":"leetcode/flood-fill.html","title":"733.Flood Fill","keywords":"","body":"733. Flood Fill Difficulty: Easy Topics: Depth-first Search Similar Questions: Island Perimeter Problem: An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, \"flood fill\" the image. To perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor. At the end, return the modified image. Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 and 0 . The value of each color in image[i][j] and newColor will be an integer in [0, 65535]. Solutions: class Solution { public: vector> floodFill(vector>& image, int sr, int sc, int newColor) { int m = image.size(); if (m == 0) return {}; int n = image[0].size(); if (n == 0) return {}; if (sr = m || sc = n) return {}; if (image[sr][sc] == newColor) return image; helper(image, sr, sc, m, n, image[sr][sc], newColor); return image; } void helper(vector>& image, int sr, int sc, int m, int n, int color, int newColor) { image[sr][sc] = newColor; if (sr + 1 = 0 && image[sr - 1][sc] == color) helper(image, sr - 1, sc, m, n, color, newColor); if (sc + 1 = 0 && image[sr][sc - 1] == color) helper(image, sr, sc - 1, m, n, color, newColor); } }; "},"leetcode/parse-lisp-expression.html":{"url":"leetcode/parse-lisp-expression.html","title":"736.Parse Lisp Expression","keywords":"","body":"736. Parse Lisp Expression Difficulty: Hard Topics: String Similar Questions: Ternary Expression Parser Number of Atoms Basic Calculator IV Problem: You are given a string expression representing a Lisp-like expression to return the integer value of. The syntax for these expressions is given as follows. An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable. Expressions always evaluate to a single integer. (An integer could be positive or negative.) A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr. An add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2. A mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2. For the purposes of this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names. Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on scope. Evaluation Examples: Input: (add 1 2) Output: 3 Input: (mult 3 (add 2 3)) Output: 15 Input: (let x 2 (mult x 5)) Output: 10 Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3. Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially. Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5. Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression. That final x will equal 2. Input: (let a1 3 b2 (add a1 1) b2) Output 4 Explanation: Variable names can contain digits after the first character. Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses. The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000. (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer. Solutions: class Solution { public: int evaluate(string expression) { int pos = 0; unordered_map symbols; return helper(expression, pos, symbols); } private: int getNumber(string& expression, int& pos) { int sign = 1; if (expression[pos] == '-') { sign = -1; ++pos; } int val = 0; for (; pos & symbols) { if (expression[pos] == '(') { ++pos; // remove '(' string op = getOperator(expression, pos); ++pos; // remove space if (op != \"let\") { int oprand1 = helper(expression, pos, symbols); ++pos; //remove space int oprand2 = helper(expression, pos, symbols); ++pos; // remove ')' if (op == \"add\") { return oprand1 + oprand2; } else { return oprand1 * oprand2; } } else { unordered_set add; unordered_map replace; string symbol1 = getSymbol(expression, pos); ++pos; // remove space; if (symbols.count(symbol1) > 0) { replace[symbol1] = symbols[symbol1]; } else { add.insert(symbol1); } int value1 = helper(expression, pos, symbols); ++pos; // remove space; symbols[symbol1] = value1; while(true) { int cur = pos; int val = helper(expression, pos, symbols); if (expression[pos] == ')') { for (auto& symbol : add) { symbols.erase(symbol); } for (auto& entry : replace) { symbols[entry.first] = entry.second; } ++pos; // remove ')' return val; } else { pos = cur; string symbol = getSymbol(expression, pos); ++pos; // remove space; if (symbols.count(symbol) > 0 && add.count(symbol) == 0) { replace[symbol] = symbols[symbol]; } add.insert(symbol); int value = helper(expression, pos, symbols); ++pos; // remove space; symbols[symbol] = value; } } } } else if (expression[pos] == '-' || isdigit(expression[pos])){ return getNumber(expression, pos); } else { string symbol = getSymbol(expression, pos); if (symbols.count(symbol) == 0) return -1; return symbols[symbol]; } } }; "},"leetcode/to-lower-case.html":{"url":"leetcode/to-lower-case.html","title":"742.To Lower Case","keywords":"","body":"742. To Lower Case Difficulty: Easy Topics: String Similar Questions: Problem: Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.   Example 1: Input: \"Hello\" Output: \"hello\" Example 2: Input: \"here\" Output: \"here\" Example 3: Input: \"LOVELY\" Output: \"lovely\" Solutions: class Solution { public: string toLowerCase(string str) { for (int i = 0; i = 'A' && c "},"leetcode/convert-binary-search-tree-to-sorted-doubly-linked-list.html":{"url":"leetcode/convert-binary-search-tree-to-sorted-doubly-linked-list.html","title":"758.Convert Binary Search Tree to Sorted Doubly Linked List","keywords":"","body":"758. Convert Binary Search Tree to Sorted Doubly Linked List Difficulty: Medium Topics: Linked List, Divide and Conquer, Tree Similar Questions: Binary Tree Inorder Traversal Problem: Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list. Let's take the following BST as an example, it may help you understand the problem better:     We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. The figure below shows the circular doubly linked list for the BST above. The \"head\" symbol means the node it points to is the smallest element of the linked list.     Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list. The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.   Solutions: /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* treeToDoublyList(Node* root) { if (root == NULL) return NULL; Node* dummy = new Node(0, NULL, NULL); Node* tail = dummy; helper(root, tail); tail->right = dummy->right; dummy->right->left = tail; return dummy->right; } void helper(Node* root, Node*& tail) { if (root == NULL) return; Node* left = root->left; Node* right = root->right; helper(left, tail); tail->right = root; root->left = tail; tail = root; helper(right, tail); } }; "},"leetcode/insert-into-a-binary-search-tree.html":{"url":"leetcode/insert-into-a-binary-search-tree.html","title":"784.Insert into a Binary Search Tree","keywords":"","body":"784. Insert into a Binary Search Tree Difficulty: Medium Topics: Tree Similar Questions: Search in a Binary Search Tree Problem: Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5 You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5 This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { return new TreeNode(val); } if (val == root->val) return root; if (val val) { root->left = insertIntoBST(root->left, val); } else { root->right = insertIntoBST(root->right, val); } return root; } }; "},"leetcode/shortest-path-to-get-all-keys.html":{"url":"leetcode/shortest-path-to-get-all-keys.html","title":"895.Shortest Path to Get All Keys","keywords":"","body":"895. Shortest Path to Get All Keys Difficulty: Hard Topics: Heap, Breadth-first Search Similar Questions: Problem: We are given a 2-dimensional grid. \".\" is an empty cell, \"#\" is a wall, \"@\" is the starting point, (\"a\", \"b\", ...) are keys, and (\"A\", \"B\", ...) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key. For some 1 , there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.   Example 1: Input: [\"@.a.#\",\"###.#\",\"b.A.B\"] Output: 8 Example 2: Input: [\"@..aA\",\"..B#.\",\"....b\"] Output: 6   Note: 1 1 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock. Solutions: using namespace std; class Solution { public: struct Status { int x; int y; int keys; Status(int x, int y, int keys) { this->x = x; this->y = y; this->keys = keys; } bool operator= 'a' && c = 'A' && c & grid) { int keyCount = 0; pair startPoint; int m = grid.size(); if (m == 0) return 0; int n = grid[0].length(); if (n == 0) return 0; for (int x = 0; x q; set visited; q.push({startPoint.first, startPoint.second, 0}); int steps = 0; int allKeys = (1 = m || s.y = n || grid[s.x][s.y] == '#') continue; if (visited.count(s) > 0) continue; visited.insert(s); if (isKey(grid[s.x][s.y])) { s.keys = ((s.keys) | (1 > (grid[s.x][s.y] - 'A')) & 1) != 1) { continue; } } visited.insert(s); if (s.keys == allKeys) return steps; q.push({s.x + 1, s.y, s.keys}); q.push({s.x - 1, s.y, s.keys}); q.push({s.x, s.y + 1, s.keys}); q.push({s.x, s.y - 1, s.keys}); } ++steps; } return -1; } }; "},"leetcode/middle-of-the-linked-list.html":{"url":"leetcode/middle-of-the-linked-list.html","title":"908.Middle of the Linked List","keywords":"","body":"908. Middle of the Linked List Difficulty: Easy Topics: Linked List Similar Questions: Problem: Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.   Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.   Note: The number of nodes in the given list will be between 1 and 100. Solutions: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast && fast->next) { // it is tricky! fast = fast->next->next; slow = slow->next; } return slow; } }; "},"leetcode/sort-array-by-parity.html":{"url":"leetcode/sort-array-by-parity.html","title":"941.Sort Array By Parity","keywords":"","body":"941. Sort Array By Parity Difficulty: Easy Topics: Array Similar Questions: Problem: Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.   Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.   Note: 1 0 Solutions: class Solution { public: vector sortArrayByParity(vector& A) { int left = 0; int right = A.size() - 1; while (left "},"leetcode/smallest-range-i.html":{"url":"leetcode/smallest-range-i.html","title":"944.Smallest Range I","keywords":"","body":"944. Smallest Range I Difficulty: Easy Topics: Math Similar Questions: Problem: Given an array A of integers, for each integer A[i] we may choose any x with -K , and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.   Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1] Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8] Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]   Note: 1 0 0 Solutions: class Solution { public: int smallestRangeI(vector& A, int K) { if (A.size() == 0) return 0; int minVal = A[0]; int maxVal = A[0]; for (int i = 1; i "},"leetcode/verifying-an-alien-dictionary.html":{"url":"leetcode/verifying-an-alien-dictionary.html","title":"990.Verifying an Alien Dictionary","keywords":"","body":"990. Verifying an Alien Dictionary Difficulty: Easy Topics: Hash Table Similar Questions: Problem: In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.   Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).   Note: 1 1 order.length == 26 All characters in words[i] and order are english lowercase letters. Solutions: class Solution { public: bool isAlienSorted(vector& words, string order) { vector m(26); for (int i = 0; i 0 && words[i] "},"leetcode/convert-to-base-2.html":{"url":"leetcode/convert-to-base-2.html","title":"1070.Convert to Base -2","keywords":"","body":"1070. Convert to Base -2 Difficulty: Medium Topics: Math Similar Questions: Problem: Given a number N, return a string consisting of \"0\"s and \"1\"s that represents its value in base -2 (negative two). The returned string must have no leading zeroes, unless the string is \"0\".   Example 1: Input: 2 Output: \"110\" Explantion: (-2) ^ 2 + (-2) ^ 1 = 2 Example 2: Input: 3 Output: \"111\" Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3 Example 3: Input: 4 Output: \"100\" Explantion: (-2) ^ 2 = 4   Note: 0 Solutions: class Solution { public: string baseNeg2(int N) { if (N == 0) return \"0\"; string ret; while (N != 0) { if (N % 2 == 0) { ret.push_back('0'); N /= -2; } else { ret.push_back('1'); N -= 1; N /= -2; } } reverse(ret.begin(), ret.end()); return ret; } }; "},"leetcode/two-sum-less-than-k.html":{"url":"leetcode/two-sum-less-than-k.html","title":"1083.Two Sum Less Than K","keywords":"","body":"1083. Two Sum Less Than K Difficulty: Easy Topics: Array Similar Questions: Two Sum Two Sum II - Input array is sorted 3Sum Smaller Subarray Product Less Than K Problem: Given an array A of integers and integer K, return the maximum S such that there exists i with A[i] + A[j] = S and S . If no i, j exist satisfying this equation, return -1.   Example 1: Input: A = [34,23,1,24,75,33,54,8], K = 60 Output: 58 Explanation: We can use 34 and 24 to sum 58 which is less than 60. Example 2: Input: A = [10,20,30], K = 15 Output: -1 Explanation: In this case it's not possible to get a pair sum less that 15.   Note: 1 1 1 Solutions: class Solution { public: int twoSumLessThanK(vector& A, int K) { if (A.size() = K) { --right; } else { ret = max(ret, A[left] + A[right]); ++left; } } return ret == INT_MIN ? -1 : ret; } }; "},"leetcode/number-of-days-in-a-month.html":{"url":"leetcode/number-of-days-in-a-month.html","title":"1088.Number of Days in a Month","keywords":"","body":"1088. Number of Days in a Month Difficulty: Easy Topics: Similar Questions: Problem: Given a year Y and a month M, return how many days there are in that month.   Example 1: Input: Y = 1992, M = 7 Output: 31 Example 2: Input: Y = 2000, M = 2 Output: 29 Example 3: Input: Y = 1900, M = 2 Output: 28   Note: 1583 1 Solutions: class Solution { public: int numberOfDays(int Y, int M) { int dayNum[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; if (Y % 100 == 0) { if (Y % 400 == 0) { dayNum[1] = 29; } } else { if (Y % 4 == 0) { dayNum[1] = 29; } } return dayNum[M - 1]; } }; "},"leetcode/check-if-a-number-is-majority-element-in-a-sorted-array.html":{"url":"leetcode/check-if-a-number-is-majority-element-in-a-sorted-array.html","title":"1102.Check If a Number Is Majority Element in a Sorted Array","keywords":"","body":"1102. Check If a Number Is Majority Element in a Sorted Array Difficulty: Easy Topics: Array, Binary Search Similar Questions: Majority Element Majority Element II Problem: Given an array nums sorted in non-decreasing order, and a number target, return True if and only if target is a majority element. A majority element is an element that appears more than N/2 times in an array of length N.   Example 1: Input: nums = [2,4,5,5,5,5,5,6,6], target = 5 Output: true Explanation: The value 5 appears 5 times and the length of the array is 9. Thus, 5 is a majority element because 5 > 9/2 is true. Example 2: Input: nums = [10,100,101,101], target = 101 Output: false Explanation: The value 101 appears 2 times and the length of the array is 4. Thus, 101 is not a majority element because 2 > 4/2 is false.   Note: 1 1 1 Solutions: class Solution { public: bool isMajorityElement(vector& nums, int target) { if (nums.size() == 0) return false; int l1 = 0; int l2 = 0; int r1 = nums.size() - 1; int r2 = nums.size() - 1; while (true) { if (l1 = target) { r1 = mid; } else { l1 = mid + 1; } } if (l1 > r1) return false; if (l2 r2) return false; if (l2 - r1 + 1 > int(nums.size() / 2)) { // trap! return true; } if (r2 - l1 + 1 "},"leetcode/find-words-that-can-be-formed-by-characters.html":{"url":"leetcode/find-words-that-can-be-formed-by-characters.html","title":"1112.Find Words That Can Be Formed by Characters","keywords":"","body":"1112. Find Words That Can Be Formed by Characters Difficulty: Easy Topics: Array, Hash Table Similar Questions: Problem: You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words.   Example 1: Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\" Output: 6 Explanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6. Example 2: Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\" Output: 10 Explanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.   Note: 1 1 All strings contain lowercase English letters only. Solutions: class Solution { public: int countCharacters(vector& words, string chars) { unordered_map charCount; for (auto c : chars) { ++charCount[c]; } int ret = 0; for (auto& word : words) { if (valid(word, charCount)) { ret += word.length(); } } return ret; } private: bool valid(string& word, unordered_map charCount) { for (auto c : word) { if ((--charCount[c]) "},"leetcode/maximum-level-sum-of-a-binary-tree.html":{"url":"leetcode/maximum-level-sum-of-a-binary-tree.html","title":"1116.Maximum Level Sum of a Binary Tree","keywords":"","body":"1116. Maximum Level Sum of a Binary Tree Difficulty: Medium Topics: Graph Similar Questions: Problem: Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on. Return the smallest level X such that the sum of all the values of nodes at level X is maximal.   Example 1: Input: [1,7,0,7,-8,null,null] Output: 2 Explanation: Level 1 sum = 1. Level 2 sum = 7 + 0 = 7. Level 3 sum = 7 + -8 = -1. So we return the level with the maximum sum which is level 2.   Note: The number of nodes in the given tree is between 1 and 10^4. -10^5 Solutions: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxLevelSum(TreeNode* root) { if (root == nullptr) return 0; unordered_map sums; helper(root, 1, sums); int maxSum = INT_MIN; int maxLevel = -1; for (auto& entry : sums) { if (entry.second > maxSum) { maxSum = entry.second; maxLevel = entry.first; } else if (entry.second == maxSum && entry.first & sums) { sums[level] += root->val; if (root->left) { helper(root->left, level + 1, sums); } if (root->right) { helper(root->right, level + 1, sums); } } }; "},"leetcode/parsing-a-boolean-expression.html":{"url":"leetcode/parsing-a-boolean-expression.html","title":"1197.Parsing A Boolean Expression","keywords":"","body":"1197. Parsing A Boolean Expression Difficulty: Hard Topics: String Similar Questions: Problem: Return the result of evaluating a given boolean expression, represented as a string. An expression can either be: \"t\", evaluating to True; \"f\", evaluating to False; \"!(expr)\", evaluating to the logical NOT of the inner expression expr; \"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...; \"|(expr1,expr2,...)\", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...   Example 1: Input: expression = \"!(f)\" Output: true Example 2: Input: expression = \"|(f,t)\" Output: true Example 3: Input: expression = \"&(t,f)\" Output: false Example 4: Input: expression = \"|(&(t,f,t),!(t))\" Output: false   Constraints: 1 expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}. expression is a valid expression representing a boolean, as given in the description. Solutions: class Solution { public: bool negate(string& expression, int& pos) { bool ret = !helper(expression, pos); ++pos; // remove ) return ret; } bool logicAdd(string& expression, int& pos) { bool ret = true; do { ret = helper(expression, pos) && ret; } while (expression[pos++] == ','); return ret; } bool logicOr(string& expression, int& pos) { bool ret = false; do { ret = helper(expression, pos) || ret; } while (expression[pos++] == ','); return ret; } bool parseBoolExpr(string expression) { int pos = 0; return helper(expression, pos); } bool helper(string& expression, int& pos) { //bool ret; //for (;pos "},"leetcode/day-of-the-year.html":{"url":"leetcode/day-of-the-year.html","title":"1260.Day of the Year","keywords":"","body":"1260. Day of the Year Difficulty: Easy Topics: Math Similar Questions: Problem: Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.   Example 1: Input: date = \"2019-01-09\" Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2: Input: date = \"2019-02-10\" Output: 41 Example 3: Input: date = \"2003-03-01\" Output: 60 Example 4: Input: date = \"2004-03-01\" Output: 61   Constraints: date.length == 10 date[4] == date[7] == '-', and all other date[i]'s are digits date represents a calendar date between Jan 1st, 1900 and Dec 31, 2019. Solutions: class Solution { public: int dayOfYear(string date) { int year = 0; for (int i = 0; i "}}